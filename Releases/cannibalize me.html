<!-- Qualtrics Survey Header -->

<!-- Container for the version tabs -->
<div id="mv-tabs-container">
    <ul class="mv-tabs"><!-- Tabs will be dynamically generated here by JavaScript -->
    </ul>
    </div>

<!-- JavaScript Library (svlib) -->
<script type="text/javascript">
// Wrap everything in Qualtrics addOnReady to ensure elements exist
Qualtrics.SurveyEngine.addOnload(function () {
  console.groupCollapsed("Qualtrics.SurveyEngine.addOnload: Custom JavaScript");

  svlib.log("MV Tabs: Initializing multi-version tab system on this page.");

  // Find ALL multi-version containers on the current page.
  const mvContainers = document.querySelectorAll(".mv-container");

  if (mvContainers.length === 0) {
    svlib.log("MV Tabs: No '.mv-container' elements found on this page. Exiting.");
    console.groupEnd(); // Close the group before exiting
    return;
  }

  svlib.log("MV Tabs: Found %d '.mv-container' elements.", mvContainers.length);

  // --- Process Each Container Independently ---
  mvContainers.forEach((mvContainer, containerIndex) => {
    svlib.log(
      "MV Tabs: Processing container #%d: %o",
      containerIndex + 1,
      mvContainer
    );

    // Find all direct child version divs within THIS specific container
    const versions = mvContainer.querySelectorAll(":scope > .mv-version");
    svlib.log(
      "MV Tabs: Container #%d has %d versions.",
      containerIndex + 1,
      versions.length
    );

    if (versions.length === 0) {
        svlib.log(
        "MV Tabs: Container #%d has no '.mv-version' divs. Skipping tab generation for it.",
        containerIndex + 1
      );
      return; // Move to the next container
    }

    // --- Create Tab Bar Elements Dynamicsally ---
    const tabBarDiv = document.createElement("div");
    tabBarDiv.className = "mv-tab-bar"; // Use class for styling

    const tabsUl = document.createElement("ul");
    tabsUl.className = "mv-tabs"; // Use class for styling

    // --- Tab Generation for this container ---
    versions.forEach((versionDiv, versionIndex) => {
      const name = versionDiv.dataset.name || `Version ${versionIndex + 1}`;
      svlib.log(
        "MV Tabs: Container #%d, Version #%d: Name='%s'",
        containerIndex + 1,
        versionIndex + 1,
        name
      );

      const li = document.createElement("li");
      const a = document.createElement("a");
      a.textContent = name;
      a.href = "#"; // Prevent page jump
      // Store the index relative to THIS container's versions
      a.dataset.versionIndex = versionIndex;

      // --- Event Listener for Tab Clicks (Scoped) ---
      // Note: Logging within this listener will happen WHEN a tab is clicked,
      // which is after the initial onload function completes.
      a.addEventListener("click", function (event) {
        event.preventDefault(); // Stop the '#' link behavior

        // 'this' is the clicked <a> tag
        const clickedTabIndex = parseInt(this.dataset.versionIndex, 10);
        svlib.log(
          "MV Tabs: Tab clicked: '%s' (Index: %d) in Container #%d",
          this.textContent,
          clickedTabIndex,
          containerIndex + 1
        );

        // Find the specific elements related ONLY to this tab set
        // Go up to the parent <li>, then parent <ul>
        const currentTabsUl = this.closest("ul.mv-tabs");
        // The container is the next sibling element after the tab bar div
        const currentContainer = currentTabsUl.parentElement.nextElementSibling;

        if (!currentContainer || !currentContainer.classList.contains("mv-container")) {
            svlib.log("MV Tabs: ERROR - Could not find associated .mv-container for the clicked tab!");
            return;
        }

        const currentVersions = currentContainer.querySelectorAll(":scope > .mv-version");

        // 1. Deactivate all tabs and content panes within THIS specific system
        currentTabsUl.querySelectorAll("a").forEach((tabLink) => {
          tabLink.classList.remove("active");
        });
        currentVersions.forEach((contentPane) => {
          contentPane.classList.remove("active");
        });

        // 2. Activate the clicked tab
        this.classList.add("active");

        // 3. Activate the corresponding content pane
        if (currentVersions[clickedTabIndex]) {
          currentVersions[clickedTabIndex].classList.add("active");
          svlib.log(
            "MV Tabs: Activated content pane index %d for container #%d: %o",
            clickedTabIndex,
            containerIndex + 1,
            currentVersions[clickedTabIndex]
          );
        } else {
            svlib.log(
            "MV Tabs: ERROR - Content pane index %d not found for container #%d!",
            clickedTabIndex,
            containerIndex + 1
          );
        }
      }); // End event listener

      li.appendChild(a);
      tabsUl.appendChild(li);
    }); // End version loop for this container

    // Append the UL to the Tab Bar Div
    tabBarDiv.appendChild(tabsUl);

    // --- Insert the Tab Bar into the DOM ---
    // Place the newly created tab bar div *before* its corresponding mvContainer
    mvContainer.parentNode.insertBefore(tabBarDiv, mvContainer);
    svlib.log(
      "MV Tabs: Inserted tab bar before container #%d.",
      containerIndex + 1
    );

    // --- Initial State for this container ---
    // Activate the first tab and the first version content
    if (tabsUl.firstChild && tabsUl.firstChild.firstChild) {
      tabsUl.firstChild.firstChild.classList.add("active");
    }
    if (versions[0]) {
      versions[0].classList.add("active");
    }
  }); // End container loop

  svlib.log("MV Tabs: Initialization complete for this page.");

  // NOW, close the group after all synchronous setup is done.
  console.groupEnd();

}); // End Qualtrics.SurveyEngine.addOnload


Qualtrics.SurveyEngine.addOnPageSubmit(function () {
    svlib.storeFeedbackAsEmbeddedData();
});






  // Create a single global object to act as a namespace
  var svlib = svlib || {};

  // --- State Management (Conceptual - needs loading/saving) ---
  // We'll manage state within functions for now, assuming load/save happens
  // It's often better to load state once at the start of addOnReady

  // --- Helper Functions ---

    svlib.log = function() {
    // Usage: svlib.log("Format string %s", value1, value2, ...);
        if (svlib.DEBUG_MODE) {
        // Convert the arguments object into a real array
        const originalArgs = Array.from(arguments);

        // Check if there are any arguments
        if (originalArgs.length > 0) {
        // Prepend "[DEBUG] " to the *first* argument, assuming it's the format string
        // Use String() to handle cases where the first arg might not be a string initially
        const formatString = "[DEBUG] " + String(originalArgs[0]);

        // Get the rest of the arguments (values for substitution)
        const substitutionValues = originalArgs.slice(1);

        // Create the final arguments array for the native console.log
        // Start with the modified format string, then add the substitution values
        const finalArgs = [formatString].concat(substitutionValues);

        // Call the native console.log using .apply() with the new arguments array
        // This ensures format specifiers in the modified first argument are processed
        console.log.apply(console, finalArgs);
        } else {
        // If svlib.log() was called with no arguments, just log the prefix
        console.log("[DEBUG]");
        }
        }
    };

    svlib.success = function() {
    // Usage: svlib.success("Format string %s", value1, value2, ...);
        if (svlib.DEBUG_MODE) {
        // Convert the arguments object into a real array
        const originalArgs = Array.from(arguments);

        // Check if there are any arguments
        if (originalArgs.length > 0) {
        // Prepend "[SUCCESS] " to the *first* argument, assuming it's the format string
        const formatString = "[SUCCESS] " + String(originalArgs[0]);

        // Get the rest of the arguments (values for substitution)
        const substitutionValues = originalArgs.slice(1);

        // Create the final arguments array for the native console.log
        const finalArgs = [formatString].concat(substitutionValues);

        // Call the native console.log using .apply() with the new arguments array
        console.log.apply(console, finalArgs);
        } else {
        // If svlib.success() was called with no arguments, just log the prefix
        console.log("[SUCCESS]");
        }
        }
    };

    svlib.warn = function() {
    // Usage: svlib.warn("Format string %s", value1, value2, ...);
        if (svlib.DEBUG_MODE) {
        // Convert the arguments object into a real array
        const originalArgs = Array.from(arguments);

        // Check if there are any arguments
        if (originalArgs.length > 0) {
        // Prepend "[WARNING] " to the *first* argument, assuming it's the format string
        const formatString = "[WARNING] " + String(originalArgs[0]);

        // Get the rest of the arguments (values for substitution)
        const substitutionValues = originalArgs.slice(1);

        // Create the final arguments array for the native console.warn
        const finalArgs = [formatString].concat(substitutionValues);

        // Call the native console.warn using .apply() with the new arguments array
        console.warn.apply(console, finalArgs);
        } else {
        // If svlib.warn() was called with no arguments, just log the prefix
        console.warn("[WARNING]");
        }
        }
    };

    svlib.error = function() {
    // Usage: svlib.error("Format string %s", value1, value2, ...);
        if (svlib.DEBUG_MODE) {
        // Convert the arguments object into a real array
        const originalArgs = Array.from(arguments);

        // Check if there are any arguments
        if (originalArgs.length > 0) {
        // Prepend "[ERROR] " to the *first* argument, assuming it's the format string
        const formatString = "[ERROR] " + String(originalArgs[0]);

        // Get the rest of the arguments (values for substitution)
        const substitutionValues = originalArgs.slice(1);

        // Create the final arguments array for the native console.error
        const finalArgs = [formatString].concat(substitutionValues);

        // Call the native console.error using .apply() with the new arguments array
        console.error.apply(console, finalArgs);
        } else {
        // If svlib.error() was called with no arguments, just log the prefix
        console.error("[ERROR]");
        }
        }
    };


    svlib.DEBUG_MODE = false; // Default to false

    (function() { // Use an IIFE to avoid polluting global scope further
    try {
        const urlParams = new URLSearchParams(window.location.search);

        // Check for Qualtrics Preview Mode URL parameters
        if (urlParams.get('debug')?.toLowerCase() === 'true' ||
            urlParams.get('feedback')?.toLowerCase() === 'true' ||
            urlParams.get('Q_CHL')?.toLowerCase() === 'preview') {
            svlib.DEBUG_MODE = true;
            svlib.log("svlib: Preview mode detected, DEBUG_MODE enabled.");
        }
        } catch (e) {
            console.error("svlib: Error during debug mode detection.", e);
            // Leave DEBUG_MODE as its default (false)
        }

        let navMode = null;
        try {
            navMode = this.navMode && this.navMode();
            console.log("svlib: navMode detected:", navMode);
        }
        catch (e) {
            console.error("svlib: Error during navMode detection.", e);
            // Leave navMode as its default (false)
        }
        if (navMode) {
            svlib.DEBUG_MODE = true;
            svlib.log("svlib: navMode detected, DEBUG_MODE enabled.");
        } else {
            svlib.log("svlib: navMode not detected.");
        }

        const inIframe = window.self !== window.top;
        console.log("window.self !== window.top → %o", inIframe);
        if (inIframe) {
            svlib.DEBUG_MODE = true;
            svlib.log("svlib: IFRAME detected, DEBUG_MODE enabled.");
        } else {
            svlib.log("svlib: No IFRAME detected.");
        }
    })(); // End of IIFE for debug detection



    svlib.testDataPersistence = function testDataPersistence() {
    // Usage: svlib.testDataPersistence.call(this);
        console.group("testDataPersistence");
        const questionId = this.questionId;

        // Testing embedded data persistence
        // Warning: Qualtrics.SurveyEngine.getEmbeddedData() is deprecated and will return null in the "simple layout".
        console.group("calling testEmbed"); // Survey Flow: Set "testEmbed" to "default value of testEmbed"
            svlib.log("testEmbed: %s", Qualtrics.SurveyEngine.getJSEmbeddedData("testEmbed")); // Prints: "default value of __js_testEmbed"
            svlib.log("Setting to 'NEW VALUE of testEmbed'...");
            Qualtrics.SurveyEngine.setJSEmbeddedData("testEmbed", "NEW VALUE of testEmbed"); // Doesn't persist through refresh, but successfully sets "__js_testEmbed" to "NEW VALUE of testEmbed" upon page submission.
            svlib.log("Retrieving testEmbed again (check against final response form): %s", Qualtrics.SurveyEngine.getJSEmbeddedData("testEmbed")); // Prints: "NEW VALUE of testEmbed"
        console.groupEnd();

        console.group("calling __js_testEmbed"); // Survey Flow: Set "__js_testEmbed" to "default value of __js_testEmbed"
            svlib.log("__js_testEmbed: %s", Qualtrics.SurveyEngine.getJSEmbeddedData("__js_testEmbed")); // Prints: "default value of __js___js_testEmbed"
            svlib.log("Setting to 'NEW VALUE of __js_testEmbed'...");
            Qualtrics.SurveyEngine.setJSEmbeddedData("__js_testEmbed", "NEW VALUE of __js_testEmbed"); // Doesn't persist through refresh, but successfully sets "__js___js_testEmbed" to "NEW VALUE of __js_testEmbed" upon page submission.
            svlib.log("Retrieving __js_testEmbed again (check against final response form): %s", Qualtrics.SurveyEngine.getJSEmbeddedData("__js_testEmbed")); // Prints: "NEW VALUE of __js_testEmbed"
        console.groupEnd();

        console.group("calling __js___js_testEmbed"); // Survey Flow: Set "__js___js_testEmbed" to "default value of __js___js_testEmbed"
            svlib.log("__js___js_testEmbed: %s", Qualtrics.SurveyEngine.getJSEmbeddedData("__js___js_testEmbed")); // Prints: undefined
            svlib.log("Setting to 'NEW VALUE of __js___js_testEmbed'...");
            Qualtrics.SurveyEngine.setJSEmbeddedData("__js___js_testEmbed", "NEW VALUE of __js___js_testEmbed"); // Doesn't persist through refresh and does not set any embedded data in the final response form (since it's looking for a non-existent "__js___js___js_testEmbed" in the survey flow), but DOES persist on page submit and can be loaded on the next page (returning "NEW VALUE of __js___js_testEmbed" instead of undefined).
            svlib.log("Retrieving __js___js_testEmbed again (check against final response form): %s", Qualtrics.SurveyEngine.getJSEmbeddedData("__js___js_testEmbed")); // Prints: "NEW VALUE of __js___js_testEmbed"
        console.groupEnd();

        // Testing sessionStorage persistence
        let sessionData = sessionStorage.getItem("testData") ?? null;
        if (sessionData) {
            svlib.success("Session data loaded:", sessionData);
        } else {
            svlib.warn("No session data found. Embedding...");
            sessionData = "session test string";
            sessionStorage.setItem("testData", sessionData);
        }

        // Testing localStorage persistence
        let localData = localStorage.getItem("testData") ?? null;
        if (localData) {
            svlib.success("Local data loaded:", localData);
        } else {
            svlib.warn("No local data found. Embedding...");
            localData = "local test string";
            localStorage.setItem("testData", localData);
        }
        console.groupEnd();
    };


  // --- Core Library Functions ---

    svlib.describeThisQuestion = function describeThisQuestion() {
        // Usage: svlib.describeThisQuestion.call(this);
        console.groupCollapsed("describeThisQuestion(%s)", this.questionId);
        const questionInfo = this.getQuestionInfo();
        console.log("Question Info: ", questionInfo); // All info in questionInfo is *before* any other changes (e.g., randomization).
        console.log("this.getChoices(): ", this.getChoices()); // this.getChoices() returns the order of the choices as they are displayed to the user (e.g., ['2', '3', '1']).
        console.groupEnd();
    };

    svlib.thisQuestionHasAltText = function thisQuestionHasAltText() {
        const questionElement = this.getQuestionTextContainer();
        
        // Extract the full text of the question
        let text = questionElement.innerHTML;

        // Regex to find all #HEADER# sections and their content
        const regex = /#([A-z0-9_]+)#([\s\S]*?)(?=#([A-z0-9_]+)#|$)/gi;
        
        let versions = {};
        let match;

        while ((match = regex.exec(text)) !== null) {
            let header = match[1].trim();
            let content = match[2].trim();
            versions[header] = content;
        }

        // Get all detected headers (keys) dynamically
        let keys = Object.keys(versions);
        if (keys.length === 0) return; // If no headers found, exit script

        // Default to the first version found
        let currentKey = keys[0];
        questionElement.innerHTML = versions[currentKey];

        // Create a dropdown for selection
        let toggleDropdown = document.createElement("select");
        toggleDropdown.style.position = "absolute";
        toggleDropdown.style.right = "10px"; 
        toggleDropdown.style.top = "10px"; 
        toggleDropdown.style.padding = "5px";
        toggleDropdown.style.backgroundColor = "#0073e6";
        toggleDropdown.style.color = "white";
        toggleDropdown.style.border = "none";
        toggleDropdown.style.cursor = "pointer";
        toggleDropdown.style.borderRadius = "5px";

        // Populate dropdown with detected versions
        for (let key of keys) {
            let option = document.createElement("option");
            option.value = key;
            option.textContent = key;
            toggleDropdown.appendChild(option);
        }

        // Append dropdown to the question container
        let container = this.getQuestionContainer();
        container.style.position = "relative";
        container.appendChild(toggleDropdown);

        // Toggle function on selection change
        toggleDropdown.onchange = function() {
            currentKey = toggleDropdown.value;
            questionElement.innerHTML = versions[currentKey];
        };
    };




    svlib.thisQuestionHasPortraits = function thisQuestionHasPortraits() {

        // Retrieve the embedded JSON as a string
        var portraitURLsJSON = '${e://Field/PortraitURLsJSON}';
        console.log("Raw PortraitURLs JSON:", portraitURLsJSON);

        try {
            // Parse the JSON string into a JavaScript object
            var portraitURLs = JSON.parse(portraitURLsJSON);
            console.log("Parsed Portrait URLs:", portraitURLs);

            // Randomly select one URL from Male and one from Female
            function getRandomURL(category) {
                let keys = Object.keys(category); // Get all keys (e.g., "Jessica", "Michael")
                let randomKey = keys[Math.floor(Math.random() * keys.length)]; // Select a random key
                return category[randomKey]; // Return the URL for the random key
            }

            let randomFemaleURL = getRandomURL(portraitURLs.Female);
            let randomMaleURL = getRandomURL(portraitURLs.Male);

            console.log("Random Female URL:", randomFemaleURL);
            console.log("Random Male URL:", randomMaleURL);

            // Update the images for choices 1 and 2
            let choiceElements = document.querySelectorAll(".choice");
            console.log("Choice elements:", choiceElements);

            if (choiceElements.length >= 2) {
                // Update Choice 1 with the random Female URL
                let image1 = choiceElements[0].querySelector(".expandable-image img");
                if (image1) {
                    image1.src = randomFemaleURL; // Set the new image URL
                    image1.alt = "Random Female Image"; // Update alt text for accessibility
                }

                // Update Choice 2 with the random Male URL
                let image2 = choiceElements[1].querySelector(".expandable-image img");
                if (image2) {
                    image2.src = randomMaleURL; // Set the new image URL
                    image2.alt = "Random Male Image"; // Update alt text for accessibility
                }
            }
        } catch (error) {
            console.error("Error parsing PortraitURLs JSON:", error);
        }

    };

    
    svlib.thisQuestionIsExampleCQ = function thisQuestionIsExampleCQ() {
        // Usage: svlib.thisQuestionIsExampleCQ.call(this);
        // This function creates an example comprehension question. It's not recorded and can be reset with a button.
    };

    
    svlib.thisQuestionIsCQ = function thisQuestionIsCQ() {
        // Usage: svlib.thisQuestionIsCQ.call(this);
        // This function handles ALL operations functionalities relating to a comprehension question's choices and scoring.
        svlib.randomizeMultChoiceOrder.call(this);
        svlib.addResponseListenerMC.call(this, svlib.listenerRecordResponseMC);
	    svlib.replayColors.call(this);

        Qualtrics.SurveyEngine.addOnPageSubmit(function() {
            svlib.checkAttemptsCQ.call(this, this.questionId);
        });
    };

   


    svlib.randomizeMultChoiceOrder = function randomizeMultChoiceOrder(choicesToRandomizeIndices = null) {
    // Usage: svlib.randomizeMultChoiceOrder.call(this, choiceIndicesToRandomize);
    // Randomizes the order of the specified choices in a multiple-choice question. If no indices are provided, it randomizes all choices.
        const questionContainer = this.getQuestionContainer();
        const questionId = this.questionId;
        console.groupCollapsed("randomizeMultChoiceOrder(%s, indices: %o)", questionId, choicesToRandomizeIndices);

        if (!questionContainer) {
        svlib.log("Safety check failed: questionContainer not found for %s", questionId);
        console.groupEnd();
        return;
        }
        const choicesContainer = questionContainer.querySelector(".choices");
        if (!choicesContainer) {
        svlib.log("Safety check failed: choicesContainer not found for %s", questionId);
        console.groupEnd();
        return;
        }
        let answerChoiceElements = Array.from(questionContainer.querySelectorAll(".choice"));
        if (!answerChoiceElements || answerChoiceElements.length === 0) {
        svlib.log("Safety check failed: no .choice elements found for %s", questionId);
        console.groupEnd();
        return;
        }

        // --- Start of 1-based to 0-based conversion ---
        let internalIndicesToRandomize = null;
        const randomizeAll = !Array.isArray(choicesToRandomizeIndices) || choicesToRandomizeIndices.length === 0;

        if (!randomizeAll) {
            internalIndicesToRandomize = choicesToRandomizeIndices
                .map(oneBasedIndex => oneBasedIndex - 1) // Convert 1-based to 0-based
                .filter(zeroBasedIndex => zeroBasedIndex >= 0 && zeroBasedIndex < answerChoiceElements.length); // Basic validation

            if (internalIndicesToRandomize.length !== choicesToRandomizeIndices.length) {
                svlib.warn("Some provided 1-based indices were invalid for question %s.", questionId);
            }
            svlib.log("Converted 1-based indices %o to 0-based indices: %o", choicesToRandomizeIndices, internalIndicesToRandomize);
        }
        // --- End of 1-based to 0-based conversion ---


        let choiceOrder = svlib.loadSessionJson(questionId + "_choiceOrder");
        svlib.log("Loaded choice order: %o", choiceOrder);

        let finalOrderedElements;

        if (!choiceOrder) { // No previous order, so randomize and save.
            svlib.log("Randomizing choice order for %s.", questionId);

            // Save the natural order (text content based) - stays 0-based internally
            svlib.saveSessionJson(questionId + "_naturalChoiceOrder", answerChoiceElements.map(choice => {
                const textEl = choice.querySelector('.choice-label .rich-text');
                return textEl ? textEl.textContent.trim() : '';
            }));

            let elementsToRandomize = [];
            let fixedElements = [];
            let fixedElementPositions = {}; // To remember the original positions of fixed elements (0-based)

            answerChoiceElements.forEach((element, index) => { // Loop uses 0-based index
                // Check if the current 0-based index is in the list of indices to randomize
                if (randomizeAll || (internalIndicesToRandomize && internalIndicesToRandomize.includes(index))) {
                    elementsToRandomize.push(element);
                } else {
                    fixedElements.push(element);
                    fixedElementPositions[index] = element; // Store by original 0-based index
                }
            });

            // Shuffle only the elements marked for randomization
            const shuffledRandomizedElements = svlib.shuffleArray(elementsToRandomize);
            svlib.log("Shuffled %d elements.", shuffledRandomizedElements.length);


            // Reconstruct the final order (using 0-based logic)
            finalOrderedElements = [];
            let randomizedIndex = 0;
            for (let i = 0; i < answerChoiceElements.length; i++) { // Iterate through original 0-based positions
                if (fixedElementPositions[i]) {
                    finalOrderedElements.push(fixedElementPositions[i]);
                } else {
                    // Add from the shuffled list for positions that were randomized
                    // Ensure we don't go out of bounds if there's a logic error
                    if (randomizedIndex < shuffledRandomizedElements.length) {
                        finalOrderedElements.push(shuffledRandomizedElements[randomizedIndex]);
                        randomizedIndex++;
                    } else {
                        // This case shouldn't happen if logic is correct, but good defensive coding
                        svlib.error("Mismatch during reconstruction for question %s. Not enough shuffled elements.", questionId);
                    }

                }
            }

            // Save the *final* calculated order (text content) for restoration
            const currentChoiceOrder = finalOrderedElements.map(choice => {
                const textEl = choice.querySelector('.choice-label .rich-text');
                return textEl ? textEl.textContent.trim() : '';
            });
            svlib.saveSessionJson(questionId + "_choiceOrder", currentChoiceOrder);
            svlib.log("Saved new choice order: %o", currentChoiceOrder);


        } else { // Restoring order from session storage
            svlib.log("Restoring choice order for %s.", questionId);
            // Restoration logic remains the same as it matches saved text content to current elements
            finalOrderedElements = [];
            const currentChoiceTexts = answerChoiceElements.map(choice => {
                const textEl = choice.querySelector('.choice-label .rich-text');
                return textEl ? textEl.textContent.trim() : '';
            });
            const currentChoiceTextSet = new Set(currentChoiceTexts);

            choiceOrder.forEach(savedText => {
                const elementIndex = currentChoiceTexts.indexOf(savedText);
                if (elementIndex !== -1) {
                    finalOrderedElements.push(answerChoiceElements[elementIndex]);
                } else {
                    // Handle cases where choices might have changed or were removed
                    svlib.warn("Could not find current element matching saved text '%s' in question %s during restoration. This choice might have been removed or changed.", savedText, questionId);
                }
            });

            // Add any new choices that weren't in the original randomized set to the end
            answerChoiceElements.forEach(element => {
                const textEl = element.querySelector('.choice-label .rich-text');
                const currentText = textEl ? textEl.textContent.trim() : '';
                // Check if the current text is not in the set of texts that were successfully restored
                if (currentText && !choiceOrder.includes(currentText)) {
                    svlib.log("Adding newly found choice '%s' to the end of the restored order for %s.", currentText, questionId);
                    finalOrderedElements.push(element);
                }
            });

            // Basic check for consistency after restoration
            if (finalOrderedElements.length !== answerChoiceElements.length) {
                svlib.warn("Number of restored elements (%d) does not match current number of choices (%d) for question %s after processing. Display order may be inconsistent.", finalOrderedElements.length, answerChoiceElements.length, questionId);
            } else {
                // Verify that all original elements are now in finalOrderedElements (they should be if counts match)
                const restoredTexts = new Set(finalOrderedElements.map(choice => {
                    const textEl = choice.querySelector('.choice-label .rich-text');
                    return textEl ? textEl.textContent.trim() : '';
                }));
                const allOriginalElementsRestored = currentChoiceTexts.every(text => restoredTexts.has(text));
                if (!allOriginalElementsRestored) {
                    svlib.error("Logic error: Element count matches after restoration for %s, but not all original elements are present in the restored set.", questionId);
                    // This indicates a deeper issue in the restoration filtering/adding logic
                }
            }
            svlib.log("Restoration complete for %s.", questionId);
        }

        // Apply the final ordered elements to the DOM within a try/catch for robustness
        if (finalOrderedElements && finalOrderedElements.length > 0) {
            try {
                choicesContainer.innerHTML = ""; // Clear existing
                finalOrderedElements.forEach(choiceElement => {
                    // Simple check before appending in case an element somehow became null/undefined
                    if (choiceElement) {
                        choicesContainer.appendChild(choiceElement);
                    } else {
                        svlib.warn("Attempted to append a null or undefined element for question %s.", questionId);
                    }
                });
                svlib.log("Applied ordered choice elements to DOM for %s.", questionId);
            } catch (error) {
                svlib.error("Error applying ordered choice elements to DOM for %s: %o", questionId, error);
                // Depending on severity, you might want to throw the error or halt further processing
                // throw error; // Example: Re-throw to stop execution if critical
            }

        } else if (answerChoiceElements.length > 0) {
            // Handle case where there are choices but finalOrderedElements is empty
            svlib.error("Final ordered elements array is empty for question %s, but choices were found. DOM update skipped.", questionId);
        } else {
            // This case is likely caught by the initial safety check
            svlib.log("No choice elements found or processed for DOM update for question %s.", questionId);
        }

        console.groupEnd();
    };

    svlib.getLabelTextMC = function getLabelTextMC(inputElement) {
        let label = inputElement.closest("label");
        if (!label && inputElement.id) {
            label = document.querySelector(`label[for="${inputElement.id}"]`);
        }
        return label ? label.innerText.trim() : "(No label found)";
    };


    svlib.replayColors = function replayColors() {
    // Usage: svlib.replayColors.call(this);
        
        const questionId = svlib.normalizeQuestionId(this.questionId);
        console.groupCollapsed("replayColors(%s)", questionId);
        const colorMap = svlib.loadSessionJson(questionId + "_colorHistory") ?? {};
        
        Object.entries(colorMap).forEach(([responseText, color]) => {
            // `record: false` avoids re‐writing the history
            svlib.colorResponse.call(this, questionId, responseText, color, {
                record: false,
            });
        });
        console.groupEnd();
    };

    svlib.applyColorMap = function applyColorMap(questionId, colorMap = {}) {
        // Usage: svlib.applyColorMap(questionId, colorMap);
        console.groupCollapsed("applyColorMap(%s, %o)", questionId, colorMap);
        colorMap = colorMap || svlib.loadSessionJson(questionId + "_colorMap") || {};
        if (colorMap) {
            svlib.log("Loaded color map: %o", colorMap);
            questionInstance = Qualtrics.SurveyEngine.QuestionData.getInstance(questionId);
            const questionContainer = questionInstance.getQuestionContainer();
            if (!questionContainer) { /* ... safety check ... */ return; }
            const choiceElements = questionContainer.querySelectorAll(".choice-label");
            // svlib.log("Found %d choice elements.", choiceElements.length);
            choiceElements.forEach((choice) => {
                const choiceId = choice.control.id.split("-").pop()
                const color = colorMap[choiceId] || "";
                choice.style.backgroundColor = color;
                svlib.log("Applied color %s to choiceId %s.", color, choiceId);
                
            });
        } else {
            svlib.log("No color map found for question %s.", questionId);
            
        }
        console.groupEnd();
    };



    svlib.hideQuestionInDetailsContainer = function hideQuestionInDetailsContainer(summaryText = "Click to expand question") {
        // Usage: svlib.hideQuestionInDetailsContainer.call(this, "Click to view question");
        const questionId = this.questionId;
        const questionContainer = this.getQuestionContainer();
        const parentElement = questionContainer.parentElement;
        
        questionContent = questionContainer.querySelector(".question-content");
        questionContainer.classList.add("svlib-details-question");
        
        // Create new details container and summary and place question container inside it
        const detailsContainer = document.createElement("details");
        const summary = document.createElement("summary");
        summary.textContent = summaryText;
        
        if (parentElement) {
            svlib.log("Parent element found for question %s: %o", questionId, parentElement);
            parentElement.insertBefore(detailsContainer, questionContainer);
        } else {
            svlib.error("Parent element not found for question %s.", questionId);
        }

        detailsContainer.appendChild(summary);
        detailsContainer.appendChild(questionContainer);
    };

    

    svlib.addLoopBreaker = function addLoopBreaker(breakOn = [1]) {
        // Usage: svlib.addLoopBreaker.call(this, breakOn = [1]);
        // This function adds a listener that updates an embedded variable used in display logic.
        // If the specified choice is clicked, then the loop will break.
        const questionContainer = this.getQuestionContainer();
        const questionId = svlib.normalizeQuestionId(this.questionId);

        questionContainer.addEventListener('click', (event) => {
            if (!event.target.matches('input[type="radio"], input[type="checkbox"]')) { return; }
            setTimeout(() => {
                const thisChoiceId = parseInt(event.target.id.split("-").pop());
                let selectedChoices = this.getSelectedChoices().map(Number);

                if (breakOn.includes(thisChoiceId)) {
                    if (selectedChoices.includes(thisChoiceId)) {
                        svlib.log("Loop breaker activated on choice %s.", thisChoiceId);
                        Qualtrics.SurveyEngine.setJSEmbeddedData(questionId + "_loopBreaker", "break");
                    } else {
                        svlib.log("Loop breaker deactivated on choice %s.", thisChoiceId);
                        Qualtrics.SurveyEngine.setJSEmbeddedData(questionId + "_loopBreaker", "loop");
                    }
                }
            }, 0);
        });
    };


    svlib.persistOnRefresh = function persistOnRefresh() {
        // Usage: svlib.persistOnRefresh.call(this);
        // This function is called on page refresh to save the current state of the question.
        // const questionId = svlib.normalizeQuestionId(this.questionId);
        const questionId = this.questionId;
        const questionContainer = this.getQuestionContainer();
        const colorMap = svlib.loadSessionJson(questionId + "_colorMap") || {};
        svlib.applyColorMap(questionId, colorMap);
    };


    svlib.addRefreshButtonMC = function addRefreshButtonMC() {
        // Usage: svlib.addResetButtonMC.call(this);
        // Adds a reset button to the question container that resets the color map and response history.
        const questionContainer = this.getQuestionContainer();
        
        const resetButton = document.createElement("button");
        resetButton.innerText = "Reset";
        resetButton.style.backgroundColor = "#0073e6";
        resetButton.style.color = "white";
        resetButton.style.border = "none";
        resetButton.style.cursor = "pointer";
        resetButton.style.borderRadius = "5px";
        resetButton.style.padding = "5px 10px";
        resetButton.style.marginBottom = "10px";

        const questionContentDiv = questionContainer.querySelector(".question-content");
        questionContentDiv.insertAdjacentElement("afterbegin", resetButton);


        resetButton.addEventListener("mouseover", () => {
            resetButton.style.backgroundColor = "#005bb5";
        });

        resetButton.addEventListener("mouseout", () => {
            resetButton.style.backgroundColor = "#0073e6";
        });

        resetButton.addEventListener("click", () => {
            console.group("Reset button clicked for %s", questionId);
            svlib.saveSessionJson(questionId + "_colorMap", {});
            svlib.saveSessionJson(questionId + "_responseHistory", []);
            svlib.saveSessionJson(questionId + "_choiceOrder", []);
            svlib.log("Color map and response history cleared. Refreshing...");
            console.groupEnd();
            window.location.reload(); // Refresh the page to apply changes
        });
    };

    svlib.addPseudoResetButtonMC = function addPseudoResetButtonMC(loopBreakerQID = null) {
        // Usage: svlib.addPseudoResetButtonMC.call(this, loopBreakerQID = "QID51");
        // Adds a reset button to the question container that resets the color map and response history.
        const questionContainer = this.getQuestionContainer();
        
        const resetButton = document.createElement("button");
        resetButton.innerText = "Reset";
        resetButton.style.backgroundColor = "#0073e6";
        resetButton.style.color = "white";
        resetButton.style.border = "none";
        resetButton.style.cursor = "pointer";
        resetButton.style.borderRadius = "5px";
        resetButton.style.padding = "5px 10px";
        resetButton.style.marginBottom = "10px";

        const questionContentDiv = questionContainer.querySelector(".question-content");
        questionContentDiv.insertAdjacentElement("afterbegin", resetButton);


        resetButton.addEventListener("mouseover", () => {
            resetButton.style.backgroundColor = "#005bb5";
        });

        resetButton.addEventListener("mouseout", () => {
            resetButton.style.backgroundColor = "#0073e6";
        });

        // let questionId = svlib.normalizeQuestionId(this.questionId);
        let questionId = this.questionId;

        resetButton.addEventListener("click", () => {
            console.group("Reset button clicked for %s", this.questionId);
            svlib.saveSessionJson(questionId + "_colorMap", {});
            svlib.saveSessionJson(questionId + "_responseHistory", []);
            svlib.saveSessionJson(questionId + "_choiceOrder", []);
            svlib.log("Color map and response history cleared. Refreshing...");
            console.groupEnd();
            // svlib.applyColorMap(this.questionId, {});
            if (loopBreakerQID) {
                Qualtrics.SurveyEngine.setJSEmbeddedData(loopBreakerQID + "_loopBreaker", "loop");
                svlib.log("%s = 'loop'", loopBreakerQID + "_loopBreaker");
            }

            setTimeout(() => {
                this.clickNextButton(); // Continues to next iteration of the loop
            }, 0);
            
        });
    };

    svlib.addButtonBelowQuestionText = function addButtonBelowQuestionText(buttonText = "Click Me", buttonFunction = null, opts = {}) {
        // Usage: svlib.addButtonBelowQuestionText.call(this, buttonText, buttonFunction);
        // Adds a button below the question text.
        const questionContainer = this.getQuestionContainer();
        const questionContentDiv = questionContainer.querySelector(".question-content");
        const button = document.createElement("button");
        button.innerText = buttonText;
        button.style.backgroundColor = "#0073e6";
        button.style.color = "white";
        button.style.border = "none";
        button.style.cursor = "pointer";
        button.style.borderRadius = "5px";
        button.style.padding = "5px 10px";
        button.style.marginBottom = "10px";
        questionContentDiv.insertAdjacentElement("afterbegin", button);

        button.addEventListener("mouseover", () => {
            button.style.backgroundColor = "#005bb5";
        });

        button.addEventListener("mouseout", () => {
            button.style.backgroundColor = "#0073e6";
        });

        button.addEventListener("click", () => {
            console.group("%s Button clicked for %s", buttonText, this.questionId);
            if (buttonFunction) {
                buttonFunction.call(this, opts);
            }
            console.groupEnd();
        });
    };

    svlib.buttonFunctionExpandText = function buttonFunctionExpandText(opts = {}) {
        // Usage: svlib.addButtonBelowQuestionText.call(this, "More Info", svlib.buttonFunctionExpandText, { buttonName: "Extra Info" });
        // This function expands additional text in the question container.
        const questionContainer = this.getQuestionContainer();
        let questionTextContainer = this.getQuestionTextContainer();
        let questionText = questionTextContainer.innerHTML;
        svlib.log("Expanding text for %s", this.questionId);
        // Search for the button name in the question text, then wrap the button name and the text below it in a div. The div will be expanded/hidden if the button is clicked.

        const buttonName = opts.buttonName || "Extra Info";

        svlib.log("buttonName: ", buttonName);
        svlib.log("questionTextContainer: ", questionTextContainer);
        svlib.log("questionText: ", questionText);
        
    };

    svlib.buttonFunctionResetComprehensionExamples = function buttonFunctionResetComprehensionExamples(opts) {
        // Usage: svlib.addButtonBelowQuestionText.call(this, "Reset", svlib.buttonFunctionResetComprehensionExamples, { loopBreakerQID: "QID51" });
        const questionId = this.questionId;
        svlib.saveSessionJson(questionId + "_colorMap", {});
        svlib.saveSessionJson(questionId + "_responseHistory", []);
        svlib.saveSessionJson(questionId + "_choiceOrder", []);
        svlib.log("Color map and response history cleared.");
        Qualtrics.SurveyEngine.setJSEmbeddedData(opts.loopBreakerQID + "_loopBreaker", "loop");
        svlib.log("%s = 'loop'", opts.loopBreakerQID + "_loopBreaker");
        setTimeout(() => {
            this.clickNextButton(); // Continues to next iteration of the loop
        }, 0);
    };


    svlib.updateResponseHistoryMC = function updateResponseHistoryMC(questionId, choiceId, choiceText) {
    // Usage: svlib.updateResponseHistory(questionId, choiceId, choiceText);
        console.groupCollapsed("updateResponseHistoryMC(%s)", questionId);
        let history = svlib.loadSessionJson(questionId + "_responseHistory") || [];
        if (!Array.isArray(history)) {
            history = [];
        }
        history.push([choiceId, choiceText]);
        svlib.saveSessionJson(questionId + "_responseHistory", history);
        console.groupEnd();
    };

    svlib.applyColorToChoice = function applyColorToChoice(questionId, choiceId, color) {
        // Usage: svlib.applyColorToChoice(questionId, choiceId, color);
        // Maybe I actually want to pass event.target?
        console.groupCollapsed("applyColorToChoice(%s, %s, %s)", questionId, choiceId, color);
        const qInstance = Qualtrics.SurveyEngine.QuestionData.getInstance(questionId);
        const questionContainer = qInstance.getQuestionContainer();
        if (!questionContainer) { /* ... safety check ... */ return; }
        const choiceElements = questionContainer.querySelectorAll(".choice-label .rich-text");
        console.log("choiceElements:", choiceElements);
        // <input 

        console.groupEnd();
    };


    svlib.colorResponse = function colorResponse(questionId, responseText, color, { record = true } = {}) {
    // Usage: svlib.colorResponse.call(this, questionId, responseText);
    // TODO: take choiceId instead of responseText.
        console.groupCollapsed("colorResponse(%s, %s)", questionId, responseText);
        qInstance = Qualtrics.SurveyEngine.QuestionData.getInstance(questionId);
        const questionContainer = qInstance.getQuestionContainer();
        if (!questionContainer) { /* ... safety check ... */ return; }
        // We want to apply the background color to the div class="choice-error".
        const choiceElements = questionContainer.querySelectorAll(".choice-label .rich-text");
        const choiceElement = Array.from(choiceElements).find((el) => {
            const text = el.textContent.trim();
            return text === responseText;
        });
        if (choiceElement) {
            const label = choiceElement.closest(".choice-label");
            if (!label) {
                svlib.warn("colorResponse: Could not find label for choice element:", choiceElement);
                return;
            }
            // Apply the color to the label
            label.style.backgroundColor = color;
        } else {
            svlib.warn("colorResponse: Could not find label in choice element:", questionContainer);
        }

        if (record) {
            const historyKey = `${questionId}_colorHistory`;
            // Load existing map or start fresh
            const colorMap = svlib.loadSessionJson(questionId + "_colorHistory") ?? {};
            colorMap[responseText] = color;
            svlib.saveSessionJson(questionId + "_colorHistory", colorMap);
            svlib.log("  → recorded colorHistory:", colorMap);
        }
            console.groupEnd();
    };


    


    svlib.checkAttemptsCQ = function checkAttemptsCQ(questionId, correctIndex = 0) {
    // Usage: let attemptsTaken = svlib.checkAttemptsCQ.call(this, this.questionId);
        console.groupCollapsed("checkAttemptsCQ(%s, correctIndex=%s)", questionId, correctIndex);
        // const questionId = this.questionId;
        const responseHistory = svlib.loadSessionJson(questionId + "_responseHistory") || [];
        const naturalChoiceOrder = svlib.loadSessionJson(questionId + "_naturalChoiceOrder");
        const correctIndexText = naturalChoiceOrder[correctIndex];
        let attemptsTaken = null;

        if (responseHistory.length === 0) {
            svlib.log("No responses recorded yet.");
        }
        else if (responseHistory.length > 0) {
            // From 0 to check_up_to, check if the response is correct. Record the first correct response.
            for (let i = 0; i < responseHistory.length; i++) {
                const responseText = responseHistory[i];
                if (responseText === correctIndexText) {
                    attemptsTaken = i + 1;
                    svlib.log("Correct response found in %s attempts: %s", attemptsTaken, responseText);
                    break;
                }
            }
        }
        // Append attemptsTaken to the CQ Attempts data
        let attemptsData = svlib.loadSessionJson("attemptsTakenCQ") ?? {};
        attemptsData[questionId] = attemptsTaken;
        svlib.saveSessionJson("attemptsTakenCQ", attemptsData);
        console.groupEnd();
        return attemptsTaken;
    };

    svlib.checkAttemptsCQOnUnload = function checkAttemptsCQOnUnload() {
        // Usage: svlib.checkAttemptsCQOnUnload.call(this); this can be called in .addOnload() or .addOnReady().
        console.groupCollapsed("checkAttemptsCQOnUnload()");
        const questionId = this.questionId;
        const that = this;

        Qualtrics.SurveyEngine.addOnUnload(function () {
            const attempts = svlib.checkAttemptsCQ.call(that, questionId);
        });
        console.groupEnd();
    };

    svlib.scoreAttemptsCQ = function scoreAttemptsCQ(attemptsTaken, payoff_ladder) {
    // Usage: svlib.scoreAttemptsCQ.call(this, payoff_ladder);
    // We'll probably set payoff_ladder as an embedded variable; remember to assign it before calling this function.
    // TODO: We can checkAttempts on Submit, but don't score until the end of the survey. Maybe keep a list of attemptsTaken, then sum them at the end. We don't want resubmitting to keep incrementing the score.
        console.groupCollapsed("scoreAttemptsCQ(payoff_ladder=%s)", payoff_ladder);
        const questionId = this.questionId;



        console.groupEnd();
    };


    svlib.hideChoices = function hideChoices(choiceIndexes) {
    // Usage: svlib.hideChoices.call(this, choiceIndexes);
    // Note: Hiding before randomization will not affect the randomization process. Example: hideChoices(this, [3]) ensures that the natural choice 3 is hidden, and the other choices are shown in a randomized order.
        const questionContainer = this.getQuestionContainer();
        const allChoices = questionContainer.querySelectorAll(".choice.radio");
        choiceIndexes.forEach((index) => {
            const target = allChoices[index - 1]; // Adjust for 0-based index
            if (target) {
                target.style.display = "none";
            }
        });
    };


    svlib.hideChoicesUnlessDebug = function hideChoicesUnlessDebug(choiceIndexes) {
    // Usage: svlib.hideChoicesUnlessDebug.call(this, choiceIndexes);
        if (svlib.DEBUG_MODE == false) {
            svlib.hideChoices.call(this, choiceIndexes);
        };
    };

    svlib.markChoicesAsCursed = function markChoicesAsCursed(choiceIndexes) {
    // Usage: svlib.markChoicesAsCursed.call(this, choiceIndexes);
    // For each index in choiceIndexes, add an event listener to the choice. If clicked, start the TextCorruptor and remove the listener.
    // If the choice is selected on page submit, then set sessionStorage("cursed") to true.

        const questionContainer = this.getQuestionContainer();
        const allChoices = questionContainer.querySelectorAll(".choice.radio");
        choiceIndexes.forEach((index) => {
            const target = allChoices[index - 1]; // Adjust for 0-based index
            if (target) {
                target.classList.add("cursed");
                target.addEventListener("click", function () {
                    svlib.log("Cursed choice clicked. Starting TextCorruptor.");
                    const corruptor = new svlib.TextCorruptor(questionContainer, { baseInterval: 5000, minInterval: 100, growthFactor: 1.1, baseCount: 1 });
                    corruptor.start();
                    target.removeEventListener("click", arguments.callee);
                });
            }
        });

        Qualtrics.SurveyEngine.addOnPageSubmit(function () {
            const selectedChoice = questionContainer.querySelector(".choice.radio input:checked");
            // const selectedChoice = this.getSelectedChoices();
            // TODO: Probably compare to natural choice order. Also, decouple the randomization from the other functions.
            svlib.log("Selected choice on submit: %o", selectedChoice);
            if (selectedChoice) {
                const selectedIndex = Array.from(allChoices).indexOf(selectedChoice[0]);
                if (choiceIndexes.includes(selectedIndex + 1)) {
                    svlib.log("Selected choice index: %s. Marking as cursed...", selectedIndex);
                    sessionStorage.setItem("cursed", "true");
                }
            }
        });
    };


    svlib.checkIfCursed = function checkIfCursed() {
    // Usage: svlib.checkIfCursed.call(this);
    // If the session variable "cursed" is "true", then the TextCorruptor is started.
        const questionContainer = this.getQuestionContainer();
        const cursed = sessionStorage.getItem("cursed");
        svlib.log("Checking if cursed: %s", cursed);
        if (cursed === "true") {
            svlib.log("Cursed embedded variable is true. Starting TextCorruptor.");
            const corruptor = new svlib.TextCorruptor(questionContainer, { baseInterval: 5000, minInterval: 100, growthFactor: 1.1, baseCount: 1 });
            corruptor.start();
        }
    };


    svlib.collectTextNodes = function collectTextNodes(root) {
        // Usage: 
        const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, null, false);
        const nodes = [];
        while ((node = walker.nextNode())) {
            if (node.nodeType === Node.TEXT_NODE && node.nodeValue.trim() !== "") {
                nodes.push(node);
            }
        }
        return nodes;

    };


    svlib.injectDiacritic = function injectDiacritic(str, diacritics) {
        if (!str) return str;
        const chars = Array.from(str);
        const pos = Math.floor(Math.random() * chars.length);
        const mark = diacritics[Math.floor(Math.random() * diacritics.length)];
        chars[pos] = chars[pos] + mark;
        return chars.join("");
    };


    svlib.TextCorruptor = class TextCorruptor {
        // Usage:
        // const corruptor = new svlib.TextCorruptor(this.getQuestionContainer(), { baseInterval: 5000, minInterval: 100, growthFactor: 1.1, baseCount: 1 });
        // corruptor.start();

        constructor(containerOrSelector, opts) {
            if (typeof containerOrSelector === "string") {
                this.container = document.querySelector(containerOrSelector);
            } else if (containerOrSelector instanceof Element) {
                this.container = containerOrSelector;
            }

            if (!this.container) {
                svlib.error("TextCorruptor: Container not found.");
                return;
            }

            Object.assign(this, {
                baseInterval: opts.baseInterval || 5000,
                minInterval: opts.minInterval || 100,
                growthFactor: opts.growthFactor || 1.1,
                baseCount: opts.baseCount || 1,
                diacritics:  [
                '\u0300', '\u0301', '\u0302', '\u0303', '\u0304', '\u0305', '\u0306',
                '\u0307', '\u0308', '\u0309', '\u030A', '\u030B', '\u030C', '\u030D',
                '\u030E', '\u030F', '\u0310', '\u0311', '\u0312', '\u0313', '\u0314',
                '\u0315', '\u0316', '\u0317', '\u0318', '\u0319', '\u031A'
                ]
            });

            this._startTime = Date.now();
            this._timer = null;
            this._tick = 0;
        };

        start() {
            svlib.log("TextCorruptor started: %s every %s ms", this.baseCount, this.baseInterval);
            this._schedule();
        }

        stop() {
            clearTimeout(this._timer);
            svlib.log("TextCorruptor stopped.");
        }

        _schedule() {
            this._timer = setTimeout(() => this._runTick(), this.interval);
        }

        _runTick() {
            this._tick += 1;

            const elapsedTime = (Date.now() - this._startTime) / 1000;
            const newInterval = Math.max(this.minInterval, this.baseInterval / Math.pow(this.growthFactor, elapsedTime));
            this.interval = newInterval;
            this.count = 1 + Math.floor(elapsedTime / 2);

            const nodes = svlib.collectTextNodes(this.container);
            if (!nodes.length) {
                svlib.warn("TextCorruptor: No text nodes found in container.");
                return;
            }
            for (let i = 0; i < this.count; i++) {
                const n = nodes[Math.floor(Math.random() * nodes.length)];
                const before = n.textContent;
                const after = svlib.injectDiacritic(before, this.diacritics);
                n.textContent = after;
            }

            this._schedule();
        }
    };







  // --- Define variables/constants as properties ---
  svlib.SURVEY_VERSION = "0.2.3";

  console.log("Custom header script loaded. svlib namespace configured. v" + svlib.SURVEY_VERSION);
</script>
<!-- End Qualtrics Survey Header -->
