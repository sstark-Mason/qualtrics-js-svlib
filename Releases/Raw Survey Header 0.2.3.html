<!-- Qualtrics Survey Header -->

<!-- Container for the version tabs -->
<div id="mv-tabs-container">
    <ul class="mv-tabs"><!-- Tabs will be dynamically generated here by JavaScript -->
    </ul>
    </div>

<!-- JavaScript Library (svlib) -->
<script type="text/javascript">
// Wrap everything in Qualtrics addOnReady to ensure elements exist
Qualtrics.SurveyEngine.addOnload(function () {
  console.groupCollapsed("Qualtrics.SurveyEngine.addOnload: Custom JavaScript");

  svlib.log("MV Tabs: Initializing multi-version tab system on this page.");

  // Find ALL multi-version containers on the current page.
  const mvContainers = document.querySelectorAll(".mv-container");

  if (mvContainers.length === 0) {
    svlib.log("MV Tabs: No '.mv-container' elements found on this page. Exiting.");
    console.groupEnd(); // Close the group before exiting
    return;
  }

  svlib.log("MV Tabs: Found %d '.mv-container' elements.", mvContainers.length);

  // --- Process Each Container Independently ---
  mvContainers.forEach((mvContainer, containerIndex) => {
    svlib.log(
      "MV Tabs: Processing container #%d: %o",
      containerIndex + 1,
      mvContainer
    );

    // Find all direct child version divs within THIS specific container
    const versions = mvContainer.querySelectorAll(":scope > .mv-version");
    svlib.log(
      "MV Tabs: Container #%d has %d versions.",
      containerIndex + 1,
      versions.length
    );

    if (versions.length === 0) {
        svlib.log(
        "MV Tabs: Container #%d has no '.mv-version' divs. Skipping tab generation for it.",
        containerIndex + 1
      );
      return; // Move to the next container
    }

    // --- Create Tab Bar Elements Dynamicsally ---
    const tabBarDiv = document.createElement("div");
    tabBarDiv.className = "mv-tab-bar"; // Use class for styling

    const tabsUl = document.createElement("ul");
    tabsUl.className = "mv-tabs"; // Use class for styling

    // --- Tab Generation for this container ---
    versions.forEach((versionDiv, versionIndex) => {
      const name = versionDiv.dataset.name || `Version ${versionIndex + 1}`;
      svlib.log(
        "MV Tabs: Container #%d, Version #%d: Name='%s'",
        containerIndex + 1,
        versionIndex + 1,
        name
      );

      const li = document.createElement("li");
      const a = document.createElement("a");
      a.textContent = name;
      a.href = "#"; // Prevent page jump
      // Store the index relative to THIS container's versions
      a.dataset.versionIndex = versionIndex;

      // --- Event Listener for Tab Clicks (Scoped) ---
      // Note: Logging within this listener will happen WHEN a tab is clicked,
      // which is after the initial onload function completes.
      a.addEventListener("click", function (event) {
        event.preventDefault(); // Stop the '#' link behavior

        // 'this' is the clicked <a> tag
        const clickedTabIndex = parseInt(this.dataset.versionIndex, 10);
        svlib.log(
          "MV Tabs: Tab clicked: '%s' (Index: %d) in Container #%d",
          this.textContent,
          clickedTabIndex,
          containerIndex + 1
        );

        // Find the specific elements related ONLY to this tab set
        // Go up to the parent <li>, then parent <ul>
        const currentTabsUl = this.closest("ul.mv-tabs");
        // The container is the next sibling element after the tab bar div
        const currentContainer = currentTabsUl.parentElement.nextElementSibling;

        if (!currentContainer || !currentContainer.classList.contains("mv-container")) {
            svlib.log("MV Tabs: ERROR - Could not find associated .mv-container for the clicked tab!");
            return;
        }

        const currentVersions = currentContainer.querySelectorAll(":scope > .mv-version");

        // 1. Deactivate all tabs and content panes within THIS specific system
        currentTabsUl.querySelectorAll("a").forEach((tabLink) => {
          tabLink.classList.remove("active");
        });
        currentVersions.forEach((contentPane) => {
          contentPane.classList.remove("active");
        });

        // 2. Activate the clicked tab
        this.classList.add("active");

        // 3. Activate the corresponding content pane
        if (currentVersions[clickedTabIndex]) {
          currentVersions[clickedTabIndex].classList.add("active");
          svlib.log(
            "MV Tabs: Activated content pane index %d for container #%d: %o",
            clickedTabIndex,
            containerIndex + 1,
            currentVersions[clickedTabIndex]
          );
        } else {
            svlib.log(
            "MV Tabs: ERROR - Content pane index %d not found for container #%d!",
            clickedTabIndex,
            containerIndex + 1
          );
        }
      }); // End event listener

      li.appendChild(a);
      tabsUl.appendChild(li);
    }); // End version loop for this container

    // Append the UL to the Tab Bar Div
    tabBarDiv.appendChild(tabsUl);

    // --- Insert the Tab Bar into the DOM ---
    // Place the newly created tab bar div *before* its corresponding mvContainer
    mvContainer.parentNode.insertBefore(tabBarDiv, mvContainer);
    svlib.log(
      "MV Tabs: Inserted tab bar before container #%d.",
      containerIndex + 1
    );

    // --- Initial State for this container ---
    // Activate the first tab and the first version content
    if (tabsUl.firstChild && tabsUl.firstChild.firstChild) {
      tabsUl.firstChild.firstChild.classList.add("active");
    }
    if (versions[0]) {
      versions[0].classList.add("active");
    }
  }); // End container loop

  svlib.log("MV Tabs: Initialization complete for this page.");

  // NOW, close the group after all synchronous setup is done.
  console.groupEnd();

}); // End Qualtrics.SurveyEngine.addOnload


Qualtrics.SurveyEngine.addOnPageSubmit(function () {
    svlib.storeFeedbackAsEmbeddedData();
});






  // Create a single global object to act as a namespace
  var svlib = svlib || {};

  // --- State Management (Conceptual - needs loading/saving) ---
  // We'll manage state within functions for now, assuming load/save happens
  // It's often better to load state once at the start of addOnReady

  // --- Helper Functions ---

    svlib.log = function() {
    // Usage: svlib.log("Format string %s", value1, value2, ...);
        if (svlib.DEBUG_MODE) {
        // Convert the arguments object into a real array
        const originalArgs = Array.from(arguments);

        // Check if there are any arguments
        if (originalArgs.length > 0) {
        // Prepend "[DEBUG] " to the *first* argument, assuming it's the format string
        // Use String() to handle cases where the first arg might not be a string initially
        const formatString = "[DEBUG] " + String(originalArgs[0]);

        // Get the rest of the arguments (values for substitution)
        const substitutionValues = originalArgs.slice(1);

        // Create the final arguments array for the native console.log
        // Start with the modified format string, then add the substitution values
        const finalArgs = [formatString].concat(substitutionValues);

        // Call the native console.log using .apply() with the new arguments array
        // This ensures format specifiers in the modified first argument are processed
        console.log.apply(console, finalArgs);
        } else {
        // If svlib.log() was called with no arguments, just log the prefix
        console.log("[DEBUG]");
        }
        }
    };

    svlib.success = function() {
    // Usage: svlib.success("Format string %s", value1, value2, ...);
        if (svlib.DEBUG_MODE) {
        // Convert the arguments object into a real array
        const originalArgs = Array.from(arguments);

        // Check if there are any arguments
        if (originalArgs.length > 0) {
        // Prepend "[SUCCESS] " to the *first* argument, assuming it's the format string
        const formatString = "[SUCCESS] " + String(originalArgs[0]);

        // Get the rest of the arguments (values for substitution)
        const substitutionValues = originalArgs.slice(1);

        // Create the final arguments array for the native console.log
        const finalArgs = [formatString].concat(substitutionValues);

        // Call the native console.log using .apply() with the new arguments array
        console.log.apply(console, finalArgs);
        } else {
        // If svlib.success() was called with no arguments, just log the prefix
        console.log("[SUCCESS]");
        }
        }
    };

    svlib.warn = function() {
    // Usage: svlib.warn("Format string %s", value1, value2, ...);
        if (svlib.DEBUG_MODE) {
        // Convert the arguments object into a real array
        const originalArgs = Array.from(arguments);

        // Check if there are any arguments
        if (originalArgs.length > 0) {
        // Prepend "[WARNING] " to the *first* argument, assuming it's the format string
        const formatString = "[WARNING] " + String(originalArgs[0]);

        // Get the rest of the arguments (values for substitution)
        const substitutionValues = originalArgs.slice(1);

        // Create the final arguments array for the native console.warn
        const finalArgs = [formatString].concat(substitutionValues);

        // Call the native console.warn using .apply() with the new arguments array
        console.warn.apply(console, finalArgs);
        } else {
        // If svlib.warn() was called with no arguments, just log the prefix
        console.warn("[WARNING]");
        }
        }
    };

    svlib.error = function() {
    // Usage: svlib.error("Format string %s", value1, value2, ...);
        if (svlib.DEBUG_MODE) {
        // Convert the arguments object into a real array
        const originalArgs = Array.from(arguments);

        // Check if there are any arguments
        if (originalArgs.length > 0) {
        // Prepend "[ERROR] " to the *first* argument, assuming it's the format string
        const formatString = "[ERROR] " + String(originalArgs[0]);

        // Get the rest of the arguments (values for substitution)
        const substitutionValues = originalArgs.slice(1);

        // Create the final arguments array for the native console.error
        const finalArgs = [formatString].concat(substitutionValues);

        // Call the native console.error using .apply() with the new arguments array
        console.error.apply(console, finalArgs);
        } else {
        // If svlib.error() was called with no arguments, just log the prefix
        console.error("[ERROR]");
        }
        }
    };


    svlib.DEBUG_MODE = false; // Default to false

    (function() { // Use an IIFE to avoid polluting global scope further
    try {
        const urlParams = new URLSearchParams(window.location.search);

        // Check for Qualtrics Preview Mode URL parameters
        if (urlParams.get('debug')?.toLowerCase() === 'true' ||
            urlParams.get('feedback')?.toLowerCase() === 'true' ||
            urlParams.get('Q_CHL')?.toLowerCase() === 'preview') {
            svlib.DEBUG_MODE = true;
            svlib.log("svlib: Preview mode detected, DEBUG_MODE enabled.");
        }
        } catch (e) {
            console.error("svlib: Error during debug mode detection.", e);
            // Leave DEBUG_MODE as its default (false)
        }

        let navMode = null;
        try {
            navMode = this.navMode && this.navMode();
            console.log("svlib: navMode detected:", navMode);
        }
        catch (e) {
            console.error("svlib: Error during navMode detection.", e);
            // Leave navMode as its default (false)
        }
        if (navMode) {
            svlib.DEBUG_MODE = true;
            svlib.log("svlib: navMode detected, DEBUG_MODE enabled.");
        } else {
            svlib.log("svlib: navMode not detected.");
        }

        const inIframe = window.self !== window.top;
        console.log("window.self !== window.top → %o", inIframe);
        if (inIframe) {
            svlib.DEBUG_MODE = true;
            svlib.log("svlib: IFRAME detected, DEBUG_MODE enabled.");
        } else {
            svlib.log("svlib: No IFRAME detected.");
        }
    })(); // End of IIFE for debug detection


    svlib.shuffleArray = function (array) {
    // Usage: svlib.shuffleArray(array);
        for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    };

    svlib.saveSessionJson = function saveSessionJson(key, jsonObj) {
        // Usage: svlib.saveSessionJson.call(this, key, jsonObj);
        console.groupCollapsed("saveSessionJson(%s, %o)", key, jsonObj);
        try
        {
            const jsonString = JSON.stringify(jsonObj);
            sessionStorage.setItem(key, jsonString);
        }
        catch (e)
        {
            svlib.error("Error saving session JSON:", e);
        }
        console.groupEnd();
    };

    svlib.loadSessionJson = function loadSessionJson(key) {
        // Usage: let obj = svlib.loadSessionJson.call(this, key);
        console.groupCollapsed("loadSessionJson(%s)", key);

        let jsonString = sessionStorage.getItem(key) ?? null;
        let jsonObj = null;

        if (jsonString && jsonString.trim() !== "") {
            svlib.log("Parsing JSON string for %s.", key);
            try
            {
                jsonObj = JSON.parse(jsonString);
                svlib.log("Parsed JSON object: %o", jsonObj);
            }
            catch (e)
            {
                svlib.error("Error parsing session JSON:", e);
            }
        } else {
            svlib.log("No valid JSON string found for %s. Returning empty obj {}.", key);
        }
        console.groupEnd();
        return jsonObj;
    };

    svlib.testDataPersistence = function testDataPersistence() {
    // Usage: svlib.testDataPersistence.call(this);
        console.group("testDataPersistence");
        const questionId = this.questionId;

        // Testing embedded data persistence
        // Warning: Qualtrics.SurveyEngine.getEmbeddedData() is deprecated and will return null in the "simple layout".
        console.group("calling testEmbed"); // Survey Flow: Set "testEmbed" to "default value of testEmbed"
            svlib.log("testEmbed: %s", Qualtrics.SurveyEngine.getJSEmbeddedData("testEmbed")); // Prints: "default value of __js_testEmbed"
            svlib.log("Setting to 'NEW VALUE of testEmbed'...");
            Qualtrics.SurveyEngine.setJSEmbeddedData("testEmbed", "NEW VALUE of testEmbed"); // Doesn't persist through refresh, but successfully sets "__js_testEmbed" to "NEW VALUE of testEmbed" upon page submission.
            svlib.log("Retrieving testEmbed again (check against final response form): %s", Qualtrics.SurveyEngine.getJSEmbeddedData("testEmbed")); // Prints: "NEW VALUE of testEmbed"
        console.groupEnd();

        console.group("calling __js_testEmbed"); // Survey Flow: Set "__js_testEmbed" to "default value of __js_testEmbed"
            svlib.log("__js_testEmbed: %s", Qualtrics.SurveyEngine.getJSEmbeddedData("__js_testEmbed")); // Prints: "default value of __js___js_testEmbed"
            svlib.log("Setting to 'NEW VALUE of __js_testEmbed'...");
            Qualtrics.SurveyEngine.setJSEmbeddedData("__js_testEmbed", "NEW VALUE of __js_testEmbed"); // Doesn't persist through refresh, but successfully sets "__js___js_testEmbed" to "NEW VALUE of __js_testEmbed" upon page submission.
            svlib.log("Retrieving __js_testEmbed again (check against final response form): %s", Qualtrics.SurveyEngine.getJSEmbeddedData("__js_testEmbed")); // Prints: "NEW VALUE of __js_testEmbed"
        console.groupEnd();

        console.group("calling __js___js_testEmbed"); // Survey Flow: Set "__js___js_testEmbed" to "default value of __js___js_testEmbed"
            svlib.log("__js___js_testEmbed: %s", Qualtrics.SurveyEngine.getJSEmbeddedData("__js___js_testEmbed")); // Prints: undefined
            svlib.log("Setting to 'NEW VALUE of __js___js_testEmbed'...");
            Qualtrics.SurveyEngine.setJSEmbeddedData("__js___js_testEmbed", "NEW VALUE of __js___js_testEmbed"); // Doesn't persist through refresh and does not set any embedded data in the final response form (since it's looking for a non-existent "__js___js___js_testEmbed" in the survey flow), but DOES persist on page submit and can be loaded on the next page (returning "NEW VALUE of __js___js_testEmbed" instead of undefined).
            svlib.log("Retrieving __js___js_testEmbed again (check against final response form): %s", Qualtrics.SurveyEngine.getJSEmbeddedData("__js___js_testEmbed")); // Prints: "NEW VALUE of __js___js_testEmbed"
        console.groupEnd();

        // Testing sessionStorage persistence
        let sessionData = sessionStorage.getItem("testData") ?? null;
        if (sessionData) {
            svlib.success("Session data loaded:", sessionData);
        } else {
            svlib.warn("No session data found. Embedding...");
            sessionData = "session test string";
            sessionStorage.setItem("testData", sessionData);
        }

        // Testing localStorage persistence
        let localData = localStorage.getItem("testData") ?? null;
        if (localData) {
            svlib.success("Local data loaded:", localData);
        } else {
            svlib.warn("No local data found. Embedding...");
            localData = "local test string";
            localStorage.setItem("testData", localData);
        }
        console.groupEnd();
    };


  // --- Core Library Functions ---

    svlib.describeThisQuestion = function describeThisQuestion() {
        // Usage: svlib.describeThisQuestion.call(this);
        console.groupCollapsed("describeThisQuestion(%s)", this.questionId);
        const questionInfo = this.getQuestionInfo();
        console.log("Question Info: ", questionInfo); // All info in questionInfo is *before* any other changes (e.g., randomization).
        console.log("this.getChoices(): ", this.getChoices()); // this.getChoices() returns the order of the choices as they are displayed to the user (e.g., ['2', '3', '1']).
        console.groupEnd();
    };

    svlib.thisQuestionHasAltText = function thisQuestionHasAltText() {
        const questionElement = this.getQuestionTextContainer();
        
        // Extract the full text of the question
        let text = questionElement.innerHTML;

        // Regex to find all #HEADER# sections and their content
        const regex = /#([A-z0-9_]+)#([\s\S]*?)(?=#([A-z0-9_]+)#|$)/gi;
        
        let versions = {};
        let match;

        while ((match = regex.exec(text)) !== null) {
            let header = match[1].trim();
            let content = match[2].trim();
            versions[header] = content;
        }

        // Get all detected headers (keys) dynamically
        let keys = Object.keys(versions);
        if (keys.length === 0) return; // If no headers found, exit script

        // Default to the first version found
        let currentKey = keys[0];
        questionElement.innerHTML = versions[currentKey];

        // Create a dropdown for selection
        let toggleDropdown = document.createElement("select");
        toggleDropdown.style.position = "absolute";
        toggleDropdown.style.right = "10px"; 
        toggleDropdown.style.top = "10px"; 
        toggleDropdown.style.padding = "5px";
        toggleDropdown.style.backgroundColor = "#0073e6";
        toggleDropdown.style.color = "white";
        toggleDropdown.style.border = "none";
        toggleDropdown.style.cursor = "pointer";
        toggleDropdown.style.borderRadius = "5px";

        // Populate dropdown with detected versions
        for (let key of keys) {
            let option = document.createElement("option");
            option.value = key;
            option.textContent = key;
            toggleDropdown.appendChild(option);
        }

        // Append dropdown to the question container
        let container = this.getQuestionContainer();
        container.style.position = "relative";
        container.appendChild(toggleDropdown);

        // Toggle function on selection change
        toggleDropdown.onchange = function() {
            currentKey = toggleDropdown.value;
            questionElement.innerHTML = versions[currentKey];
        };
    };




    svlib.thisQuestionHasPortraits = function thisQuestionHasPortraits() {

        // Retrieve the embedded JSON as a string
        var portraitURLsJSON = '${e://Field/PortraitURLsJSON}';
        console.log("Raw PortraitURLs JSON:", portraitURLsJSON);

        try {
            // Parse the JSON string into a JavaScript object
            var portraitURLs = JSON.parse(portraitURLsJSON);
            console.log("Parsed Portrait URLs:", portraitURLs);

            // Randomly select one URL from Male and one from Female
            function getRandomURL(category) {
                let keys = Object.keys(category); // Get all keys (e.g., "Jessica", "Michael")
                let randomKey = keys[Math.floor(Math.random() * keys.length)]; // Select a random key
                return category[randomKey]; // Return the URL for the random key
            }

            let randomFemaleURL = getRandomURL(portraitURLs.Female);
            let randomMaleURL = getRandomURL(portraitURLs.Male);

            console.log("Random Female URL:", randomFemaleURL);
            console.log("Random Male URL:", randomMaleURL);

            // Update the images for choices 1 and 2
            let choiceElements = document.querySelectorAll(".choice");
            console.log("Choice elements:", choiceElements);

            if (choiceElements.length >= 2) {
                // Update Choice 1 with the random Female URL
                let image1 = choiceElements[0].querySelector(".expandable-image img");
                if (image1) {
                    image1.src = randomFemaleURL; // Set the new image URL
                    image1.alt = "Random Female Image"; // Update alt text for accessibility
                }

                // Update Choice 2 with the random Male URL
                let image2 = choiceElements[1].querySelector(".expandable-image img");
                if (image2) {
                    image2.src = randomMaleURL; // Set the new image URL
                    image2.alt = "Random Male Image"; // Update alt text for accessibility
                }
            }
        } catch (error) {
            console.error("Error parsing PortraitURLs JSON:", error);
        }

    };

    
    svlib.thisQuestionIsExampleCQ = function thisQuestionIsExampleCQ() {
        // Usage: svlib.thisQuestionIsExampleCQ.call(this);
        // This function creates an example comprehension question. It's not recorded and can be reset with a button.
    };

    
    svlib.thisQuestionIsCQ = function thisQuestionIsCQ() {
        // Usage: svlib.thisQuestionIsCQ.call(this);
        // This function handles ALL operations functionalities relating to a comprehension question's choices and scoring.
        svlib.randomizeMultChoiceOrder.call(this);
        svlib.addResponseListenerMC.call(this, svlib.listenerRecordResponseMC);
	    svlib.replayColors.call(this);

        Qualtrics.SurveyEngine.addOnPageSubmit(function() {
            svlib.checkAttemptsCQ.call(this, this.questionId);
        });
    };

   


    svlib.randomizeMultChoiceOrder = function randomizeMultChoiceOrder(choicesToRandomizeIndices = null) {
    // Usage: svlib.randomizeMultChoiceOrder.call(this, choiceIndicesToRandomize);
    // Randomizes the order of the specified choices in a multiple-choice question. If no indices are provided, it randomizes all choices.
        const questionContainer = this.getQuestionContainer();
        const questionId = this.questionId;
        console.groupCollapsed("randomizeMultChoiceOrder(%s, indices: %o)", questionId, choicesToRandomizeIndices);

        if (!questionContainer) {
        svlib.log("Safety check failed: questionContainer not found for %s", questionId);
        console.groupEnd();
        return;
        }
        const choicesContainer = questionContainer.querySelector(".choices");
        if (!choicesContainer) {
        svlib.log("Safety check failed: choicesContainer not found for %s", questionId);
        console.groupEnd();
        return;
        }
        let answerChoiceElements = Array.from(questionContainer.querySelectorAll(".choice"));
        if (!answerChoiceElements || answerChoiceElements.length === 0) {
        svlib.log("Safety check failed: no .choice elements found for %s", questionId);
        console.groupEnd();
        return;
        }

        // --- Start of 1-based to 0-based conversion ---
        let internalIndicesToRandomize = null;
        const randomizeAll = !Array.isArray(choicesToRandomizeIndices) || choicesToRandomizeIndices.length === 0;

        if (!randomizeAll) {
            internalIndicesToRandomize = choicesToRandomizeIndices
                .map(oneBasedIndex => oneBasedIndex - 1) // Convert 1-based to 0-based
                .filter(zeroBasedIndex => zeroBasedIndex >= 0 && zeroBasedIndex < answerChoiceElements.length); // Basic validation

            if (internalIndicesToRandomize.length !== choicesToRandomizeIndices.length) {
                svlib.warn("Some provided 1-based indices were invalid for question %s.", questionId);
            }
            svlib.log("Converted 1-based indices %o to 0-based indices: %o", choicesToRandomizeIndices, internalIndicesToRandomize);
        }
        // --- End of 1-based to 0-based conversion ---


        let choiceOrder = svlib.loadSessionJson(questionId + "_choiceOrder");
        svlib.log("Loaded choice order: %o", choiceOrder);

        let finalOrderedElements;

        if (!choiceOrder) { // No previous order, so randomize and save.
            svlib.log("Randomizing choice order for %s.", questionId);

            // Save the natural order (text content based) - stays 0-based internally
            svlib.saveSessionJson(questionId + "_naturalChoiceOrder", answerChoiceElements.map(choice => {
                const textEl = choice.querySelector('.choice-label .rich-text');
                return textEl ? textEl.textContent.trim() : '';
            }));

            let elementsToRandomize = [];
            let fixedElements = [];
            let fixedElementPositions = {}; // To remember the original positions of fixed elements (0-based)

            answerChoiceElements.forEach((element, index) => { // Loop uses 0-based index
                // Check if the current 0-based index is in the list of indices to randomize
                if (randomizeAll || (internalIndicesToRandomize && internalIndicesToRandomize.includes(index))) {
                    elementsToRandomize.push(element);
                } else {
                    fixedElements.push(element);
                    fixedElementPositions[index] = element; // Store by original 0-based index
                }
            });

            // Shuffle only the elements marked for randomization
            const shuffledRandomizedElements = svlib.shuffleArray(elementsToRandomize);
            svlib.log("Shuffled %d elements.", shuffledRandomizedElements.length);


            // Reconstruct the final order (using 0-based logic)
            finalOrderedElements = [];
            let randomizedIndex = 0;
            for (let i = 0; i < answerChoiceElements.length; i++) { // Iterate through original 0-based positions
                if (fixedElementPositions[i]) {
                    finalOrderedElements.push(fixedElementPositions[i]);
                } else {
                    // Add from the shuffled list for positions that were randomized
                    // Ensure we don't go out of bounds if there's a logic error
                    if (randomizedIndex < shuffledRandomizedElements.length) {
                        finalOrderedElements.push(shuffledRandomizedElements[randomizedIndex]);
                        randomizedIndex++;
                    } else {
                        // This case shouldn't happen if logic is correct, but good defensive coding
                        svlib.error("Mismatch during reconstruction for question %s. Not enough shuffled elements.", questionId);
                    }

                }
            }

            // Save the *final* calculated order (text content) for restoration
            const currentChoiceOrder = finalOrderedElements.map(choice => {
                const textEl = choice.querySelector('.choice-label .rich-text');
                return textEl ? textEl.textContent.trim() : '';
            });
            svlib.saveSessionJson(questionId + "_choiceOrder", currentChoiceOrder);
            svlib.log("Saved new choice order: %o", currentChoiceOrder);


        } else { // Restoring order from session storage
            svlib.log("Restoring choice order for %s.", questionId);
            // Restoration logic remains the same as it matches saved text content to current elements
            finalOrderedElements = [];
            const currentChoiceTexts = answerChoiceElements.map(choice => {
                const textEl = choice.querySelector('.choice-label .rich-text');
                return textEl ? textEl.textContent.trim() : '';
            });
            const currentChoiceTextSet = new Set(currentChoiceTexts);

            choiceOrder.forEach(savedText => {
                const elementIndex = currentChoiceTexts.indexOf(savedText);
                if (elementIndex !== -1) {
                    finalOrderedElements.push(answerChoiceElements[elementIndex]);
                } else {
                    // Handle cases where choices might have changed or were removed
                    svlib.warn("Could not find current element matching saved text '%s' in question %s during restoration. This choice might have been removed or changed.", savedText, questionId);
                }
            });

            // Add any new choices that weren't in the original randomized set to the end
            answerChoiceElements.forEach(element => {
                const textEl = element.querySelector('.choice-label .rich-text');
                const currentText = textEl ? textEl.textContent.trim() : '';
                // Check if the current text is not in the set of texts that were successfully restored
                if (currentText && !choiceOrder.includes(currentText)) {
                    svlib.log("Adding newly found choice '%s' to the end of the restored order for %s.", currentText, questionId);
                    finalOrderedElements.push(element);
                }
            });

            // Basic check for consistency after restoration
            if (finalOrderedElements.length !== answerChoiceElements.length) {
                svlib.warn("Number of restored elements (%d) does not match current number of choices (%d) for question %s after processing. Display order may be inconsistent.", finalOrderedElements.length, answerChoiceElements.length, questionId);
            } else {
                // Verify that all original elements are now in finalOrderedElements (they should be if counts match)
                const restoredTexts = new Set(finalOrderedElements.map(choice => {
                    const textEl = choice.querySelector('.choice-label .rich-text');
                    return textEl ? textEl.textContent.trim() : '';
                }));
                const allOriginalElementsRestored = currentChoiceTexts.every(text => restoredTexts.has(text));
                if (!allOriginalElementsRestored) {
                    svlib.error("Logic error: Element count matches after restoration for %s, but not all original elements are present in the restored set.", questionId);
                    // This indicates a deeper issue in the restoration filtering/adding logic
                }
            }
            svlib.log("Restoration complete for %s.", questionId);
        }

        // Apply the final ordered elements to the DOM within a try/catch for robustness
        if (finalOrderedElements && finalOrderedElements.length > 0) {
            try {
                choicesContainer.innerHTML = ""; // Clear existing
                finalOrderedElements.forEach(choiceElement => {
                    // Simple check before appending in case an element somehow became null/undefined
                    if (choiceElement) {
                        choicesContainer.appendChild(choiceElement);
                    } else {
                        svlib.warn("Attempted to append a null or undefined element for question %s.", questionId);
                    }
                });
                svlib.log("Applied ordered choice elements to DOM for %s.", questionId);
            } catch (error) {
                svlib.error("Error applying ordered choice elements to DOM for %s: %o", questionId, error);
                // Depending on severity, you might want to throw the error or halt further processing
                // throw error; // Example: Re-throw to stop execution if critical
            }

        } else if (answerChoiceElements.length > 0) {
            // Handle case where there are choices but finalOrderedElements is empty
            svlib.error("Final ordered elements array is empty for question %s, but choices were found. DOM update skipped.", questionId);
        } else {
            // This case is likely caught by the initial safety check
            svlib.log("No choice elements found or processed for DOM update for question %s.", questionId);
        }

        console.groupEnd();
    };

    svlib.getLabelTextMC = function getLabelTextMC(inputElement) {
        let label = inputElement.closest("label");
        if (!label && inputElement.id) {
            label = document.querySelector(`label[for="${inputElement.id}"]`);
        }
        return label ? label.innerText.trim() : "(No label found)";
    };


    svlib.replayColors = function replayColors() {
    // Usage: svlib.replayColors.call(this);
        
        const questionId = svlib.normalizeQuestionId(this.questionId);
        console.groupCollapsed("replayColors(%s)", questionId);
        const colorMap = svlib.loadSessionJson(questionId + "_colorHistory") ?? {};
        
        Object.entries(colorMap).forEach(([responseText, color]) => {
            // `record: false` avoids re‐writing the history
            svlib.colorResponse.call(this, questionId, responseText, color, {
                record: false,
            });
        });
        console.groupEnd();
    };

    svlib.applyColorMap = function applyColorMap(questionId, colorMap = {}) {
        // Usage: svlib.applyColorMap(questionId, colorMap);
        console.groupCollapsed("applyColorMap(%s, %o)", questionId, colorMap);
        colorMap = colorMap || svlib.loadSessionJson(questionId + "_colorMap") || {};
        if (colorMap) {
            svlib.log("Loaded color map: %o", colorMap);
            questionInstance = Qualtrics.SurveyEngine.QuestionData.getInstance(questionId);
            const questionContainer = questionInstance.getQuestionContainer();
            if (!questionContainer) { /* ... safety check ... */ return; }
            const choiceElements = questionContainer.querySelectorAll(".choice-label");
            // svlib.log("Found %d choice elements.", choiceElements.length);
            choiceElements.forEach((choice) => {
                const choiceId = choice.control.id.split("-").pop()
                const color = colorMap[choiceId] || "";
                choice.style.backgroundColor = color;
                svlib.log("Applied color %s to choiceId %s.", color, choiceId);
                
            });
        } else {
            svlib.log("No color map found for question %s.", questionId);
            
        }
        console.groupEnd();
    };

    
    svlib.normalizeQuestionId = function normalizeQuestionId(questionId) {
        // Usage: svlib.normalizeQuestionId.call(this, questionId);
        if (questionId) {
            // Looped questions are prefixed with \d+_. We want to normalize to the base questionId.
            // Example: '1_QID1' -> 'QID1'
            questionId = questionId.replace(/^\d+_/, '');
        }
        return questionId;
    };

    svlib.compareArrays = function compareArrays(arr1, arr2) {
        // Usage: svlib.compareArrays(arr1, arr2);
        if (arr1.length !== arr2.length) {
            return false;
        }
        for (let i = 0; i < arr1.length; i++) {
            if (arr1[i] !== arr2[i]) {
                return false;
            }
        }
        return true;
    };

    svlib.storeFeedbackAsEmbeddedData = function storeFeedbackAsEmbeddedData() {
        // Usage: svlib.storeFeedbackAsEmbeddedData();
        console.groupCollapsed("Serializing and storing feedback for all questions.");

        // Find all QID + "_feedback" items in sessionStorage
        const feedbackKeys = Object.keys(sessionStorage).filter(key => key.endsWith("_feedback"));
        svlib.log("Found %d feedback keys in sessionStorage.", feedbackKeys.length);
        if (feedbackKeys.length > 0) {
            const feedbackData = {};
            feedbackKeys.forEach(key => {
                const questionId = key.split("_")[0]; // Extract QID from the key
                const feedback = sessionStorage.getItem(key);
                feedbackData[questionId] = feedback;
                svlib.log("Storing feedback for %s: %s", questionId, feedback);
            });

            // Store the feedback data as embedded data
            Qualtrics.SurveyEngine.setJSEmbeddedData("feedbackData", JSON.stringify(feedbackData));
            svlib.success("Stored feedback data as embedded data.");
        } else {
            svlib.warn("No feedback keys found in sessionStorage.");
        }
        console.groupEnd();
    };
    

 svlib.enableFeedbackOnQuestion = function enableFeedbackOnQuestion() {
    console.groupCollapsed("Entering enableFeedbackOnQuestion for question: %s", this.questionId);

    // Usage: svlib.enableFeedbackOnQuestion.call(this);

    // --- Constants and Element Creation ---
    const closedIconEmpty = "🗨️"; // Icon for opening the feedback textarea
    const closedIconFilled = "💬"; 
    const openedIcon = "✔️"; // Icon for closing the feedback textarea
    const buttonRightOffset = 10; // Distance from the right edge for the button
    const buttonTopOffset = 10; // Distance from the top edge for the button
    const textareaButtonGap = 5; // Gap between the textarea and the button

    // Create the feedback button
    const feedbackButton = document.createElement("button");
    feedbackButton.textContent = closedIconEmpty; // Set initial icon
    svlib.log("Created feedback button.");

    // Get the question ID and container
    const questionId = this.questionId;
    const questionContainer = this.getQuestionContainer();
    svlib.log("Retrieved question container for question ID: %s", questionId);

    // Find the main div for the body of question text
    const questionDisplayWrapper = questionContainer.querySelector(".question-display-wrapper");
    if (!questionDisplayWrapper) {
        svlib.log("Error: .question-display-wrapper not found in question container for question ID: %s", questionId);
        return; // Exit if the target element is not found
    }
    svlib.log("Found .question-display-wrapper.");

    // Create the feedback textarea
    const feedbackTextarea = document.createElement("textarea");
    feedbackTextarea.placeholder = "Please enter any comments about this question here.";
    svlib.log("Created feedback textarea.");

    // --- Initial Styling ---
    // Style for the feedback button
    feedbackButton.style.position = "absolute";
    // feedbackButton.style.right = `${buttonRightOffset}px`; // Position from the right
    // feedbackButton.style.top = `${buttonTopOffset}px`; // Position from the top
    feedbackButton.style.right = "10px";
    feedbackButton.style.top = "10px";
    feedbackButton.style.fontSize = "1.5em"; // Font size
    feedbackButton.style.zIndex = "1001"; // Ensure button is always above the textarea
    feedbackButton.style.backgroundColor = "transparent"; // Make button background transparent
    feedbackButton.style.border = "none"; // Remove button border
    feedbackButton.style.cursor = "pointer"; // Indicate clickable element
    feedbackButton.style.outline = "none"; // Remove outline on focus
    // Add tooltip
    feedbackButton.title = "Have feedback?";
    svlib.log("Applied initial styles to feedback button.");

    // Style for the feedback textarea
    feedbackTextarea.style.position = "absolute";
    // feedbackTextarea.style.bottom = "10px"; // Position from the bottom of the wrapper
    feedbackTextarea.style.right = "50px";
    feedbackTextarea.style.top = "10px"; // Align top edges with the button
    feedbackTextarea.style.width = "calc(100% - 60px)"; // Adjust width to make space for the button (approx)
    feedbackTextarea.style.maxWidth = "300px"; // Max width for the textarea
    feedbackTextarea.style.height = "100px"; // Initial height
    feedbackTextarea.style.maxHeight = "200px"; // Max height
    feedbackTextarea.style.zIndex = "1000"; // Ensure textarea is below the button
    feedbackTextarea.style.display = "none"; // Initially hidden
    feedbackTextarea.style.backgroundColor = "#f9f9f9"; // Slightly lighter background
    feedbackTextarea.style.border = "1px solid #ddd"; // Lighter border
    feedbackTextarea.style.borderRadius = "5px"; // Rounded corners
    feedbackTextarea.style.padding = "10px"; // Increased padding
    feedbackTextarea.style.fontSize = "1em"; // Font size
    feedbackTextarea.style.resize = "vertical"; // Allow vertical resizing only
    feedbackTextarea.style.boxShadow = "0 4px 8px rgba(0, 0, 0, 0.1)"; // More pronounced shadow
    feedbackTextarea.style.transition = "all 0.3s ease-in-out"; // Smooth transition with ease-in-out
    feedbackTextarea.style.fontFamily = "Arial, sans-serif"; // Font family
    feedbackTextarea.style.color = "#333"; // Dark text color
    feedbackTextarea.style.lineHeight = "1.6"; // Improved line height
    feedbackTextarea.style.boxSizing = "border-box"; // Include padding and border
    feedbackTextarea.style.overflowY = "auto"; // Enable vertical scrolling if needed
    feedbackTextarea.style.wordWrap = "break-word"; // Break long words
    svlib.log("Applied initial styles to feedback textarea.");

    // --- Append Elements ---
    // It's good practice to ensure the container has a position property
    // for absolute positioning of its children to work relative to it.
    if (getComputedStyle(questionDisplayWrapper).position === 'static') {
        questionDisplayWrapper.style.position = 'relative';
        svlib.log("Set questionDisplayWrapper position to 'relative'.");
    }

    // Append the button and textarea to the questionDisplayWrapper
    questionDisplayWrapper.appendChild(feedbackButton);
    questionDisplayWrapper.appendChild(feedbackTextarea);
    svlib.log("Appended feedback button and textarea to questionDisplayWrapper.");

    // --- Event Listener ---
    feedbackButton.addEventListener("click", function() {
        svlib.log("Feedback button clicked for question: %s", questionId);

        // Toggle the visibility of the textarea
        if (feedbackTextarea.style.display === "none") {
            svlib.log("Showing feedback textarea.");
            feedbackTextarea.style.display = "block";
            feedbackButton.textContent = openedIcon; // Change icon to opened
            feedbackButton.style.transform = "scaleX(1)"; // Reset mirror

            // Position the textarea to the left of the button
            // We calculate the right position based on the button's right position and its width
            feedbackTextarea.style.right = `${buttonRightOffset + feedbackButton.offsetWidth + textareaButtonGap}px`;
            feedbackTextarea.style.top = `${buttonTopOffset}px`; // Align top edges

            // Give focus to textarea
            feedbackTextarea.focus();

        } else {
            svlib.log("Hiding feedback textarea.");
            feedbackTextarea.style.display = "none";
            // Reset button position (not strictly necessary here as button position doesn't change when hidden?)
            feedbackButton.style.top = `${buttonTopOffset}px`;
            feedbackButton.style.right = `${buttonRightOffset}px`;  
        }
    });

    feedbackTextarea.addEventListener("blur", function() {
        svlib.log("Textarea lost focus.");
        const feedback = feedbackTextarea.value.trim();
        if (feedback) {
            try {
                sessionStorage.setItem(questionId + "_feedback", feedback);
                svlib.log("Feedback saved to sessionStorage for question: %s", questionId);
            } catch (e) {
                svlib.log("Error saving feedback to sessionStorage: %o", e);
            }
            feedbackButton.textContent = closedIconFilled;
            feedbackButton.style.transform = "scaleX(-1)"; // Horiz mirror to match closedIconEmpty
        } else {
            svlib.log("No feedback entered for question: %s", questionId);
            feedbackButton.textContent = closedIconEmpty; // Reset icon if no feedback
        }

        if (event.relatedTarget === feedbackButton) {
            return
        } else {
            svlib.log("Textarea blurred and focus moved elsewhere. Hiding textarea.");
            feedbackTextarea.style.display = "none"; // Hide it
        }
    });

    document.addEventListener("DOMContentLoaded", function() {
        const savedFeedback = sessionStorage.getItem(questionId + "_feedback");
        if (savedFeedback) {
            feedbackTextarea.value = savedFeedback;
            feedbackButton.textContent = closedIconFilled; // Change icon to indicate saved feedback
            svlib.log("Loaded saved feedback from sessionStorage for question: %s", questionId);
        } else {
            svlib.log("No saved feedback found in sessionStorage for question: %s", questionId);
            feedbackButton.textContent = closedIconEmpty; // Reset icon if no saved feedback
        }
    });

    svlib.log("Feedback button event listener added for question: %s. Exiting enableFeedbackOnQuestion().", questionId);
    console.groupEnd();
};



    svlib.enableFeedbackOnQuestion1 = function enableFeedbackOnQuestion1() {
        // Usage: svlib.enableFeedbackOnQuestion.call(this);
        // This function creates a feedback button for the question.

        const icon = "🔤";
        const feedbackButton = document.createElement("button");
        feedbackButton.textContent = icon;

        const questionId = this.questionId;
        const questionContainer = this.getQuestionContainer();

        // questionDisplayWrapper is the main div for the body of question text
        const questionDisplayWrapper = questionContainer.querySelector(".question-display-wrapper");

        // We'll put the button at the bottom right of the questionDisplayWrapper
        feedbackButton.style.position = "absolute";
        feedbackButton.style.right = "10px"; // Adjust as needed
        feedbackButton.style.top = "10px"; // Adjust as needed
        feedbackButton.style.fontSize = "1.5em"; // Font size
        feedbackButton.style.zIndex = "1000"; // Ensure it's on top of other elements

        // Create textarea for feedback
        const feedbackTextarea = document.createElement("textarea");
        feedbackTextarea.style.width = "100%";
        feedbackTextarea.style.height = "100px"; // Adjust as needed
        feedbackTextarea.style.position = "absolute";
        feedbackTextarea.style.right = "10px"; // Adjust as needed
        feedbackTextarea.style.bottom = "50px"; // Adjust as needed
        feedbackTextarea.style.zIndex = "1000"; // Ensure it's on top of other elements
        feedbackTextarea.style.display = "none"; // Initially hidden
        feedbackTextarea.placeholder = "Please provide your feedback here...";
        feedbackTextarea.style.backgroundColor = "#f0f0f0"; // Light gray background
        feedbackTextarea.style.border = "1px solid #ccc"; // Light gray border
        feedbackTextarea.style.borderRadius = "5px"; // Rounded corners
        feedbackTextarea.style.padding = "5px"; // Padding for better appearance
        feedbackTextarea.style.fontSize = "1em"; // Font size
        feedbackTextarea.style.resize = "none"; // Disable resizing
        feedbackTextarea.style.boxShadow = "0 2px 5px rgba(0, 0, 0, 0.1)"; // Subtle shadow for depth
        feedbackTextarea.style.transition = "all 0.3s ease"; // Smooth transition for appearance
        feedbackTextarea.style.fontFamily = "Arial, sans-serif"; // Font family
        feedbackTextarea.style.color = "#333"; // Dark text color for readability
        feedbackTextarea.style.fontWeight = "normal"; // Normal font weight
        feedbackTextarea.style.lineHeight = "1.5"; // Line height for readability
        feedbackTextarea.style.boxSizing = "border-box"; // Include padding and border in element's total width and height
        feedbackTextarea.style.overflow = "auto"; // Enable scrolling if needed
        feedbackTextarea.style.maxWidth = "300px"; // Max width for the textarea
        feedbackTextarea.style.maxHeight = "200px"; // Max height for the textarea
        feedbackTextarea.style.wordWrap = "break-word"; // Break long words to fit in the textarea



        // Append the button to the questionDisplayWrapper
        questionDisplayWrapper.appendChild(feedbackButton);
        // Append the textarea to the questionDisplayWrapper
        questionDisplayWrapper.appendChild(feedbackTextarea);

        feedbackButton.addEventListener("click", function() {
            // Toggle the visibility of the textarea
            if (feedbackTextarea.style.display === "none") {
                feedbackTextarea.style.display = "block";
                feedbackButton.textContent = "✖️"; // Change icon to close
                // Move button to the right of the textarea, in line with the top of the textarea
                feedbackButton.style.position = "absolute";
                feedbackButton.style.right = "10px"; // Adjust as needed
                feedbackButton.style.top = "10px"; // Adjust as needed
                feedbackButton.style.zIndex = "1000"; // Ensure it's on top of other elements
            } else {
                feedbackTextarea.style.display = "none";
                feedbackButton.textContent = icon; // Change icon back to original
                // Reset button position
                feedbackButton.style.position = "absolute";
                feedbackButton.style.right = "10px"; // Adjust as needed
                feedbackButton.style.top = "10px"; // Adjust as needed
                feedbackButton.style.zIndex = "1000"; // Ensure it's on top of other elements

            }
            // Collect feedback
            const feedback = feedbackTextarea.value;
            if (feedback) {
                svlib.log("Feedback for question %s: %s", questionId, feedback);
                // Optionally, you can save the feedback to session storage or send it to a server
                sessionStorage.setItem(questionId + "_feedback", feedback);
            }
        });
        console.groupEnd();
    };


    svlib.hideQuestionInDetailsContainer = function hideQuestionInDetailsContainer(summaryText = "Click to expand question") {
        // Usage: svlib.hideQuestionInDetailsContainer.call(this, "Click to view question");
        const questionId = this.questionId;
        const questionContainer = this.getQuestionContainer();
        const parentElement = questionContainer.parentElement;
        
        questionContent = questionContainer.querySelector(".question-content");
        questionContainer.classList.add("svlib-details-question");
        
        // Create new details container and summary and place question container inside it
        const detailsContainer = document.createElement("details");
        const summary = document.createElement("summary");
        summary.textContent = summaryText;
        
        if (parentElement) {
            svlib.log("Parent element found for question %s: %o", questionId, parentElement);
            parentElement.insertBefore(detailsContainer, questionContainer);
        } else {
            svlib.error("Parent element not found for question %s.", questionId);
        }

        detailsContainer.appendChild(summary);
        detailsContainer.appendChild(questionContainer);
    };

    
    svlib.comprehensionQuestionSetupMC = function comprehensionQuestionSetupMC(opts = {}) {
        // Usage: svlib.comprehensionQuestionSetupMC.call(this, opts);
        // svlib.comprehensionQuestionSetup.call(this, {
        // 	logResponse: false,
        // 	recordResponseHistory: true,
        // 	correctChoices: [1],
        // 	requiredChoices: {
        // 		page: "Comprehension_Examples",
        // 		choices: [1] }
        // });

        if (!opts.logResponse) { opts.logResponse = false; }
        if (!opts.recordResponseHistory) { opts.recordResponseHistory = false; }
        if (!opts.correctChoices) { opts.correctChoices = []; }
        if (!opts.cursedChoices) { opts.cursedChoices = []; }
        if (!opts.verbose) { opts.verbose = false; }
        if (!opts.requiredChoices) { opts.requiredChoices = {}; }

        const questionId = this.questionId;
        const questionContainer = this.getQuestionContainer();
        const choiceElements = questionContainer.querySelectorAll(".choice");
        console.groupCollapsed("comprehensionQuestionSetup(%s)", questionId);

        let revealedChoices = svlib.loadSessionJson(questionId + "_revealedChoices") || [];
        let disabledChoices = svlib.loadSessionJson(questionId + "_disabledChoices") || [];

        

        if (opts.requiredChoices) {
            // Registering this questionId with the page's requiredChoices
            this.disableNextButton();
            const normQuestionId = svlib.normalizeQuestionId(this.questionId);
            const requiredChoices = opts.requiredChoices.choices.sort();
            let requiredChoiceQuestions = svlib.loadSessionJson(opts.requiredChoices.page + "_requiredChoiceQuestions") || [];
            if (!requiredChoiceQuestions.includes(normQuestionId)) {
                requiredChoiceQuestions.push(normQuestionId);
                svlib.saveSessionJson(opts.requiredChoices.page + "_requiredChoiceQuestions", requiredChoiceQuestions);
            }
        }

        // Initial setup on load
        choiceElements.forEach((choiceElement) => {
            const input = choiceElement.querySelector('input[type="radio"], input[type="checkbox"]');
            if (!input) { return; } // Skip if no input found
            const choiceId = parseInt(input.id.split("-").pop(), 10);

            if (opts.correctChoices.includes(choiceId)) {
                choiceElement.dataset.correctness = "correct";
            } else {
                choiceElement.dataset.correctness = "incorrect";
            }

            if (opts.cursedChoices.includes(choiceId)) {
                choiceElement.dataset.cursed = "cursed";
            }

            if (revealedChoices.includes(choiceId)) {
                choiceElement.dataset.revealedColor = "revealed";
            }

            if (disabledChoices.includes(choiceId)) {
                choiceElement.dataset.choiceDisabled = "disabled";
                input.disabled = true; // Disable the input
            }
        })

        // svlib.saveSessionJson(questionId + "_revealedChoices", revealedChoices);
        // svlib.saveSessionJson(questionId + "_disabledChoices", disabledChoices);

        console.groupEnd();

        questionContainer.addEventListener("click", (event) => {
            if (!event.target.matches('input[type="radio"], input[type="checkbox"]')) { return; }
            setTimeout(() => {

                // event.target.blur();
                let choiceElement = event.target.closest(".choice");                
                const thisChoiceText = svlib.getLabelTextMC(event.target);
                const thisChoiceId = parseInt(event.target.id.split("-").pop(), 10);
                const thisChoiceLabel = event.target.labels[0];
                const thisChoiceChecked = event.target.checked; // boolean
                const questionId = event.target.name;
                const normQuestionId = svlib.normalizeQuestionId(questionId);
                    

                if (opts.logResponse) { 
                    // svlib.log("%s: Clicked choice '%s' (Id %s, checked=%s)", questionId, thisChoiceText, thisChoiceId, thisChoiceChecked);
                    console.groupCollapsed("Clicked choice '%s' (Id %s, checked=%s)", thisChoiceText, thisChoiceId, thisChoiceChecked);
                    svlib.log("event: ", event);
                    svlib.log("event.target: ", event.target);
                    svlib.log("thisChoiceId: ", thisChoiceId);
                    svlib.log("thisChoiceLabel: ", thisChoiceLabel);
                    svlib.log("thisChoiceChecked: ", thisChoiceChecked);
                    svlib.log("event.target.value: ", event.target.value);
                    console.groupEnd();
                }

                if (opts.recordResponseHistory) { svlib.updateResponseHistoryMC(questionId, thisChoiceId, thisChoiceText); }

                const selectedChoices = this.getSelectedChoices().map(Number).sort();                
                
                if (opts.correctChoices && opts.correctChoices.length > 0)  {

                    // Conditionally disable choices as follows:
                    // 1. If the choice is correct, disable upon selection (so that it can't be unselected).
                    // 2. If the choice is incorrect, keep it enabled upon selection (so that it must be unselected).
                    // 3. If the choice is incorrect, disable it upon de-selection so that it can't be re-selected.
                    // 4. Once *all* correct choices have been chosen, disable all *unselected* incorrect choices. *Selected* incorrect choices stay enabled until they're actively unselected.

                    // One way to achieve this is to check if all correct answers are selected, then loop through each choice and disable it based on the above rules. I had the idea for another method of doing this that felt like it might've not needed to iterate over each choice in the same way, but I've apparently forgotten it while typing this out.

                    console.groupCollapsed("Checking correct choices for %s", questionId);
                    const correctChoices = opts.correctChoices.map(Number).sort();

                    // Save the selected choice as revealed
                    let revealedChoices = svlib.loadSessionJson(questionId + "_revealedChoices") || [];
                    revealedChoices = new Set(revealedChoices);
                    console.log("Revealed choices: %o", revealedChoices);

                    revealedChoices.add(thisChoiceId);
                    svlib.saveSessionJson(questionId + "_revealedChoices", Array.from(revealedChoices));
                    choiceElement.dataset.revealedColor = "revealed";
                    svlib.log("Revealed choices: %o", revealedChoices);
                    console.log("Revealed choices: %o", revealedChoices);

                    // This handles multiple-select choices by not disabling incorrect selections, only incorrect de-selections.
                    if ((correctChoices.includes(thisChoiceId) && thisChoiceChecked) || (!correctChoices.includes(thisChoiceId) && !thisChoiceChecked)) {
                        choiceElement.dataset.choiceDisabled = "disabled";
                        event.target.disabled = true;
                        
                    }

                    // If input type is radio, then selecting another choice inherently deselects the previous one. This means we can immediately disable this choice.
                    if (event.target.type === "radio") {
                        event.target.disabled = true;
                    }

                    // Check if all correct choices have been selected
                    if (correctChoices.every(choice => selectedChoices.includes(choice))) {
                        // All correct choices have been selected
                        svlib.log("All correct choices selected for %s. Disabling unselected incorrect choices.", questionId);
                        choiceElements.forEach((choice) => {
                            const input = choice.querySelector('input[type="radio"], input[type="checkbox"]');
                            if (!input) { return; } // Skip if no input found
                            const thatChoiceId = parseInt(input.id.split("-").pop(), 10);
                            if (!selectedChoices.includes(thatChoiceId) && !correctChoices.includes(thatChoiceId)) {
                                choice.dataset.choiceDisabled = "disabled";
                                input.disabled = true;
                            }
                        });
                        
                    }
                    console.groupEnd();
                }

                if (opts.requiredChoices != {}) {
                    console.groupCollapsed("Checking required choices for %s", normQuestionId);
                    const requiredChoices = opts.requiredChoices.choices.sort();

                    svlib.log("Required choices: %o", requiredChoices);
                    svlib.log("Selected choices: %o", selectedChoices);

                    let requiredChoiceQuestions = svlib.loadSessionJson(opts.requiredChoices.page + "_requiredChoiceQuestions");
                    
                    
                    if (svlib.compareArrays(selectedChoices, requiredChoices)) {
                        svlib.log("All required choices for %s are passed.", normQuestionId);
                        requiredChoiceQuestions = requiredChoiceQuestions.filter((q) => q !== normQuestionId);
                        
                        if (requiredChoiceQuestions.length == 0) {
                            svlib.log("All required choices passed for %s. Enabling next button.", opts.requiredChoices.page);
                            this.enableNextButton();
                        }
                    } else {
                        svlib.log("Remaining required questions: %o", requiredChoiceQuestions);
                        if (!requiredChoiceQuestions.includes(normQuestionId)) {
                            requiredChoiceQuestions.push(normQuestionId);
                            this.disableNextButton();
                        }
                    }
                    svlib.saveSessionJson(opts.requiredChoices.page + "_requiredChoiceQuestions", requiredChoiceQuestions);
                    console.groupEnd();
                }
            }, 0);
        });
    };

    svlib.addResponseListenerMC = function addResponseListenerMC(opts = {}) {
        
        // opts = { logResponse: true, recordResponseHistory: true, correctChoices: [1], cursedChoices: [3] };
        console.groupCollapsed("addResponseListenerMC(%o)", opts);
        
        if (!opts.logResponse) { opts.logResponse = false; }
        if (!opts.recordResponseHistory) { opts.recordResponseHistory = false; }
        if (!opts.correctChoices) { opts.correctChoices = []; }
        if (!opts.cursedChoices) { opts.cursedChoices = []; }
        if (!opts.verbose) { opts.verbose = false; }
        if (!opts.requiredChoices) { opts.requiredChoices = {}; }

        let questionId = svlib.normalizeQuestionId(this.questionId);


        // let colorMap = svlib.loadSessionJson(this.questionId + "_colorMap") || {};
        // if (colorMap) {
        //     svlib.applyColorMap(this.questionId, colorMap);
        // }

        if (opts.requiredChoices != {}) {
            this.disableNextButton();
            svlib.log("requiredChoices: %o", opts.requiredChoices);
            svlib.updateRequiredChoicesPassed(opts.requiredChoices.page, questionId, false);
        }

        const questionContainer = this.getQuestionContainer();
        const choices = this.getChoices();
        questionContainer.addEventListener('click', (event) => {
            if (!event.target.matches('input[type="radio"], input[type="checkbox"]')) { return; }
            setTimeout(() => {
                const thisChoiceText = svlib.getLabelTextMC(event.target);
                const thisChoiceId = parseInt(event.target.id.split("-").pop(), 10);
                const thisChoiceLabel = event.target.labels[0];
                const thisChoiceChecked = event.target.checked; // boolean
                
                if (opts.logResponse) { 
                    svlib.log("%s: Clicked choice '%s' (Id %s, checked=%s)", questionId, thisChoiceText, thisChoiceId, thisChoiceChecked);
                    // svlib.log("event:", event);
                    // svlib.log("event.target:", event.target);
                }

                if (opts.recordResponseHistory) { svlib.updateResponseHistoryMC(questionId, thisChoiceId, thisChoiceText); }

                const selectedChoices = this.getSelectedChoices().map(Number);
                const choiceElements = questionContainer.querySelectorAll(".choice-label");
                
                if (opts.correctChoices && opts.correctChoices.length > 0)  {
                    svlib.colorChoices(this.questionId, selectedChoices, choiceElements, opts);
                }

                if (opts.requiredChoices != {}) {
                    // TODO: Update this logic.
                    console.groupCollapsed("Checking required choices for %s", questionId);
                    // Check each selected choice against the required responses, then update whether the question is passed.
                    // If all required responses are met, set the question as passed.
                    // If any required response is not met, set the question as not passed.
                    let passedArray = [];
                    let requiredChoices = opts.requiredChoices.choices;

                    choiceElements.forEach((choice) => {
                        let choiceId = choice.control.id.split("-").pop();
                        let choiceIdInt = parseInt(choiceId, 10);
                        if (selectedChoices.includes(choiceIdInt) && requiredChoices.includes(choiceIdInt)) {
                            // svlib.log("This choice is selected and required: ", choice);
                            passedArray.push(true);
                        } else if (selectedChoices.includes(choiceIdInt) && !requiredChoices.includes(choiceIdInt)) {
                            // svlib.log("This choice is selected but not required: ", choice);
                            passedArray.push(false);
                        } else if (!selectedChoices.includes(choiceIdInt) && requiredChoices.includes(choiceIdInt)) {
                            // svlib.log("This choice is required but not selected: ", choice);
                            passedArray.push(false);
                        }

                    })

                    svlib.log("Passed array: %o", passedArray);
                    let allPassed = passedArray.every((passed) => passed === true);
                    svlib.log("All passed: %s", allPassed);
                    overallPassed = svlib.updateRequiredChoicesPassed(opts.requiredChoices.page, questionId, allPassed);
                    if (overallPassed) {
                        svlib.log("All required choices passed for %s. Enabling next button.", questionId);
                        this.enableNextButton();
                    } else {
                        svlib.log("Not all required choices passed for %s. Disabling next button.", questionId);
                        this.disableNextButton();
                    }
                    console.groupEnd();
                }
                

            }, 0);

        })
        console.groupEnd();
    };


    svlib.colorChoicesStandalone = function colorChoicesStandalone(questionId, selectedChoices, choiceElements, opts) {
        console.groupCollapsed("colorChoicesStandalone(%s)", questionId);
        let colorMap = svlib.loadSessionJson(questionId + "_colorMap") || {};

        choiceElements.forEach((choice) => {
            let choiceId = parseInt(choice.control.id.split("-").pop(), 10);
            let correct = opts.correctChoices.includes(choiceId);
            let cursed = opts.cursedChoices.includes(choiceId);
            let selected = selectedChoices.includes(choiceId);
            let color = "";

            svlib.log("ChoiceId: %s, correct: %s, cursed: %s, selected: %s", choiceId, correct, cursed, selected);

            if (correct && selected) {
                choice.style.backgroundColor = "hsla(122, 87%, 57%, 1)"; // Green
                colorMap[choiceId] = "hsla(122, 87%, 57%, 0.25)"; // Quarter green
            } else if (correct && !selected) {
                choice.style.backgroundColor = colorMap[choiceId]; // Apply saved color
            } else if (cursed && selected) { // Apply black, save black
                choice.style.backgroundColor = "hsla(0, 0, 0, 1)"; // Black
                colorMap[choiceId] = "hsla(0, 0, 0, 1)"; // Black
            } else if (cursed && !selected) {
                choice.style.backgroundColor = colorMap[choiceId]; // Apply saved color
            } else if (!correct && selected) { // Apply red, save quarter red
                choice.style.backgroundColor = "hsla(0, 79%, 72%, 1)"; // Lightcoral
                colorMap[choiceId] = "hsla(0, 79%, 72%, 0.25)"; // Quarter lightcoral
            } else if (!correct && !selected) {
                choice.style.backgroundColor = colorMap[choiceId]; // Apply saved color
            }

        })
        svlib.saveSessionJson(questionId + "_colorMap", colorMap);
        console.groupEnd();
    }


    svlib.colorChoices1 = function colorChoices1(questionId, selectedChoices, choiceElements, opts) {
        // Usage: svlib.colorChoices(questionId, selectedChoices, choiceElements, opts);
        // This function colors the choices based on the selected choices and the correct/cursed choices.
        // It also saves the color map to session storage.

        let colorMap = svlib.loadSessionJson(questionId + "_colorMap") || {};
        console.groupCollapsed("Coloring choices for %s", questionId);

        // svlib.log("choices: ", choices);
        // svlib.log("selectedChoices: ", selectedChoices);

        // If selected, apply color.
        // else if not selected AND in correctChoices, remove color.
        let color = "";
        choiceElements.forEach((choice) => {
            let choiceId = choice.control.id.split("-").pop();
            let choiceIdInt = parseInt(choiceId, 10);
            if (selectedChoices.includes(choiceIdInt)) {
                // svlib.log("This choice is selected: ", choice);
                if (opts.correctChoices.includes(choiceIdInt)) {
                    svlib.log("This choice is correct: ", choice);
                    color = "hsla(120, 100%, 50%, 1)"; // Lime green
                    choice.style.backgroundColor = color;
                    colorMap[choiceId] = "";
                } else if (opts.cursedChoices.includes(choiceIdInt)) {
                    svlib.log("This choice is cursed: ", choice);
                    color = "hsla(0, 0, 0, 1)"; // Black
                    choice.style.backgroundColor = color;
                    colorMap[choiceId] = color;
                } else {
                    svlib.log("This choice is incorrect: ", choice);
                    color = "hsla(120, 50%, 80%, 1)"; // Red
                    choice.style.backgroundColor = color;
                    colorMap[choiceId] = color;
                }
            } else if (opts.correctChoices.includes(choiceIdInt)) {
                // svlib.log("This choice is correct but not selected: ", choice);
                color = "hsla(120, 100%, 50%, 0.25)"; // Lime green
            }
            
        })
        svlib.saveSessionJson(questionId + "_colorMap", colorMap);
        console.groupEnd();
    };

    svlib.updateRequiredChoicesPassed = function updateRequiredChoicesPassed(pageId, questionId, passed) {
        const storageKey = pageId + "_requiredChoicesPassed";
        let storedRequirements = sessionStorage.getItem(storageKey);
        let requirementsObject = {}; // Initialize with an empty object

        // Check if there is data in sessionStorage and parse it
        if (storedRequirements) {
            try {
                requirementsObject = JSON.parse(storedRequirements);
                // loguru.info(`Parsed stored requirements for ${pageId}: ${JSON.stringify(requirementsObject)}`); // Using loguru for Python style logging
                svlib.log("Parsed stored requirements for %s: %o", pageId, requirementsObject); // Using svlib.log for JavaScript
            } catch (error) {
                // Handle potential parsing errors (e.g., corrupted data in session storage)
                // loguru.error(`Error parsing required choices data from sessionStorage for ${pageId}: ${error}`); // Using loguru
                svlib.log("Error parsing required choices data from sessionStorage for %s: %o", pageId, error); // Using svlib.log
                // Initialize with an empty object to prevent further errors
                requirementsObject = {};
            }
        } else {
            // loguru.info(`No stored requirements found for ${pageId}. Initializing empty object.`); // Using loguru
            svlib.log("No stored requirements found for %s. Initializing empty object.", pageId); // Using svlib.log
        }

        // Update the object with the new status for the specific question
        requirementsObject[questionId] = passed;
        // loguru.info(`Updated requirements for ${pageId}, ${questionId}: ${passed}`); // Using loguru
        svlib.log("Updated requirements for %s, %s: %o", pageId, questionId, passed); // Using svlib.log


        // Convert the updated object back to a JSON string and store it
        const updatedRequirementsString = JSON.stringify(requirementsObject);
        sessionStorage.setItem(storageKey, updatedRequirementsString);

        // loguru.info(`Stored updated requirements for ${pageId}. Final state: ${updatedRequirementsString}`); // Using loguru
        svlib.log("Stored updated requirements for %s. Final state: %s", pageId, updatedRequirementsString); // Using svlib.log


        svlib.log("Passed for page %s: %o", pageId, requirementsObject);

        // Check if all required choices are passed
        let allPassed = Object.values(requirementsObject).every((passed) => passed === true);
        svlib.log("All required choices passed for %s: %s", pageId, allPassed);
        // If all required choices are passed, enable the next button
        return allPassed;
    };


    svlib.passRequiredResponsesToStorage = function passRequiredResponsesToStorage(pageID, requiredResponses = []) {
        // Usage: svlib.passRequiredResponsesToStorage.call(this, PageID, requiredResponses = {});
        // This function passes the question's required responses to session storage.
        // Another function will refer to these requirements.
        // The required responses are passed as an object with the following structure:
        // Example of overall object: { "QID1": [1], "QID2": [1, 2] }
        // If a choice isn't specified, then it is assumed to be false. This is an intentional choice to suggest using the native validation feature if you want to require just any response.

        let storedRequirements = sessionStorage.getItem(pageID + "_requiredResponses") || {};
        if (!storedRequirements == {}) {
            storedRequirements = JSON.parse(storedRequirements);
        }

        const questionId = this.questionId;
        if (!storedRequirements[questionId]) {
            storedRequirements[questionId] = requiredResponses;
        }

        storedRequirements = JSON.stringify(storedRequirements);
        sessionStorage.setItem(pageID + "_requiredResponses", storedRequirements);
        svlib.log("Stored required responses for %s: %o", questionId, requiredResponses);
    };


    svlib.addLoopBreaker = function addLoopBreaker(breakOn = [1]) {
        // Usage: svlib.addLoopBreaker.call(this, breakOn = [1]);
        // This function adds a listener that updates an embedded variable used in display logic.
        // If the specified choice is clicked, then the loop will break.
        const questionContainer = this.getQuestionContainer();
        const questionId = svlib.normalizeQuestionId(this.questionId);

        questionContainer.addEventListener('click', (event) => {
            if (!event.target.matches('input[type="radio"], input[type="checkbox"]')) { return; }
            setTimeout(() => {
                const thisChoiceId = parseInt(event.target.id.split("-").pop());
                let selectedChoices = this.getSelectedChoices().map(Number);

                if (breakOn.includes(thisChoiceId)) {
                    if (selectedChoices.includes(thisChoiceId)) {
                        svlib.log("Loop breaker activated on choice %s.", thisChoiceId);
                        Qualtrics.SurveyEngine.setJSEmbeddedData(questionId + "_loopBreaker", "break");
                    } else {
                        svlib.log("Loop breaker deactivated on choice %s.", thisChoiceId);
                        Qualtrics.SurveyEngine.setJSEmbeddedData(questionId + "_loopBreaker", "loop");
                    }
                }
            }, 0);
        });
    };


    svlib.persistOnRefresh = function persistOnRefresh() {
        // Usage: svlib.persistOnRefresh.call(this);
        // This function is called on page refresh to save the current state of the question.
        // const questionId = svlib.normalizeQuestionId(this.questionId);
        const questionId = this.questionId;
        const questionContainer = this.getQuestionContainer();
        const colorMap = svlib.loadSessionJson(questionId + "_colorMap") || {};
        svlib.applyColorMap(questionId, colorMap);
    };


    svlib.addRefreshButtonMC = function addRefreshButtonMC() {
        // Usage: svlib.addResetButtonMC.call(this);
        // Adds a reset button to the question container that resets the color map and response history.
        const questionContainer = this.getQuestionContainer();
        
        const resetButton = document.createElement("button");
        resetButton.innerText = "Reset";
        resetButton.style.backgroundColor = "#0073e6";
        resetButton.style.color = "white";
        resetButton.style.border = "none";
        resetButton.style.cursor = "pointer";
        resetButton.style.borderRadius = "5px";
        resetButton.style.padding = "5px 10px";
        resetButton.style.marginBottom = "10px";

        const questionContentDiv = questionContainer.querySelector(".question-content");
        questionContentDiv.insertAdjacentElement("afterbegin", resetButton);


        resetButton.addEventListener("mouseover", () => {
            resetButton.style.backgroundColor = "#005bb5";
        });

        resetButton.addEventListener("mouseout", () => {
            resetButton.style.backgroundColor = "#0073e6";
        });

        resetButton.addEventListener("click", () => {
            console.group("Reset button clicked for %s", questionId);
            svlib.saveSessionJson(questionId + "_colorMap", {});
            svlib.saveSessionJson(questionId + "_responseHistory", []);
            svlib.saveSessionJson(questionId + "_choiceOrder", []);
            svlib.log("Color map and response history cleared. Refreshing...");
            console.groupEnd();
            window.location.reload(); // Refresh the page to apply changes
        });
    };

    svlib.addPseudoResetButtonMC = function addPseudoResetButtonMC(loopBreakerQID = null) {
        // Usage: svlib.addPseudoResetButtonMC.call(this, loopBreakerQID = "QID51");
        // Adds a reset button to the question container that resets the color map and response history.
        const questionContainer = this.getQuestionContainer();
        
        const resetButton = document.createElement("button");
        resetButton.innerText = "Reset";
        resetButton.style.backgroundColor = "#0073e6";
        resetButton.style.color = "white";
        resetButton.style.border = "none";
        resetButton.style.cursor = "pointer";
        resetButton.style.borderRadius = "5px";
        resetButton.style.padding = "5px 10px";
        resetButton.style.marginBottom = "10px";

        const questionContentDiv = questionContainer.querySelector(".question-content");
        questionContentDiv.insertAdjacentElement("afterbegin", resetButton);


        resetButton.addEventListener("mouseover", () => {
            resetButton.style.backgroundColor = "#005bb5";
        });

        resetButton.addEventListener("mouseout", () => {
            resetButton.style.backgroundColor = "#0073e6";
        });

        // let questionId = svlib.normalizeQuestionId(this.questionId);
        let questionId = this.questionId;

        resetButton.addEventListener("click", () => {
            console.group("Reset button clicked for %s", this.questionId);
            svlib.saveSessionJson(questionId + "_colorMap", {});
            svlib.saveSessionJson(questionId + "_responseHistory", []);
            svlib.saveSessionJson(questionId + "_choiceOrder", []);
            svlib.log("Color map and response history cleared. Refreshing...");
            console.groupEnd();
            // svlib.applyColorMap(this.questionId, {});
            if (loopBreakerQID) {
                Qualtrics.SurveyEngine.setJSEmbeddedData(loopBreakerQID + "_loopBreaker", "loop");
                svlib.log("%s = 'loop'", loopBreakerQID + "_loopBreaker");
            }

            setTimeout(() => {
                this.clickNextButton(); // Continues to next iteration of the loop
            }, 0);
            
        });
    };

    svlib.addButtonBelowQuestionText = function addButtonBelowQuestionText(buttonText = "Click Me", buttonFunction = null, opts = {}) {
        // Usage: svlib.addButtonBelowQuestionText.call(this, buttonText, buttonFunction);
        // Adds a button below the question text.
        const questionContainer = this.getQuestionContainer();
        const questionContentDiv = questionContainer.querySelector(".question-content");
        const button = document.createElement("button");
        button.innerText = buttonText;
        button.style.backgroundColor = "#0073e6";
        button.style.color = "white";
        button.style.border = "none";
        button.style.cursor = "pointer";
        button.style.borderRadius = "5px";
        button.style.padding = "5px 10px";
        button.style.marginBottom = "10px";
        questionContentDiv.insertAdjacentElement("afterbegin", button);

        button.addEventListener("mouseover", () => {
            button.style.backgroundColor = "#005bb5";
        });

        button.addEventListener("mouseout", () => {
            button.style.backgroundColor = "#0073e6";
        });

        button.addEventListener("click", () => {
            console.group("%s Button clicked for %s", buttonText, this.questionId);
            if (buttonFunction) {
                buttonFunction.call(this, opts);
            }
            console.groupEnd();
        });
    };

    svlib.buttonFunctionExpandText = function buttonFunctionExpandText(opts = {}) {
        // Usage: svlib.addButtonBelowQuestionText.call(this, "More Info", svlib.buttonFunctionExpandText, { buttonName: "Extra Info" });
        // This function expands additional text in the question container.
        const questionContainer = this.getQuestionContainer();
        let questionTextContainer = this.getQuestionTextContainer();
        let questionText = questionTextContainer.innerHTML;
        svlib.log("Expanding text for %s", this.questionId);
        // Search for the button name in the question text, then wrap the button name and the text below it in a div. The div will be expanded/hidden if the button is clicked.

        const buttonName = opts.buttonName || "Extra Info";

        svlib.log("buttonName: ", buttonName);
        svlib.log("questionTextContainer: ", questionTextContainer);
        svlib.log("questionText: ", questionText);
        
    };

    svlib.buttonFunctionResetComprehensionExamples = function buttonFunctionResetComprehensionExamples(opts) {
        // Usage: svlib.addButtonBelowQuestionText.call(this, "Reset", svlib.buttonFunctionResetComprehensionExamples, { loopBreakerQID: "QID51" });
        const questionId = this.questionId;
        svlib.saveSessionJson(questionId + "_colorMap", {});
        svlib.saveSessionJson(questionId + "_responseHistory", []);
        svlib.saveSessionJson(questionId + "_choiceOrder", []);
        svlib.log("Color map and response history cleared.");
        Qualtrics.SurveyEngine.setJSEmbeddedData(opts.loopBreakerQID + "_loopBreaker", "loop");
        svlib.log("%s = 'loop'", opts.loopBreakerQID + "_loopBreaker");
        setTimeout(() => {
            this.clickNextButton(); // Continues to next iteration of the loop
        }, 0);
    };


    svlib.updateResponseHistoryMC = function updateResponseHistoryMC(questionId, choiceId, choiceText) {
    // Usage: svlib.updateResponseHistory(questionId, choiceId, choiceText);
        console.groupCollapsed("updateResponseHistoryMC(%s)", questionId);
        let history = svlib.loadSessionJson(questionId + "_responseHistory") || [];
        if (!Array.isArray(history)) {
            history = [];
        }
        history.push([choiceId, choiceText]);
        svlib.saveSessionJson(questionId + "_responseHistory", history);
        console.groupEnd();
    };

    svlib.applyColorToChoice = function applyColorToChoice(questionId, choiceId, color) {
        // Usage: svlib.applyColorToChoice(questionId, choiceId, color);
        // Maybe I actually want to pass event.target?
        console.groupCollapsed("applyColorToChoice(%s, %s, %s)", questionId, choiceId, color);
        const qInstance = Qualtrics.SurveyEngine.QuestionData.getInstance(questionId);
        const questionContainer = qInstance.getQuestionContainer();
        if (!questionContainer) { /* ... safety check ... */ return; }
        const choiceElements = questionContainer.querySelectorAll(".choice-label .rich-text");
        console.log("choiceElements:", choiceElements);
        // <input 

        console.groupEnd();
    };


    svlib.colorResponse = function colorResponse(questionId, responseText, color, { record = true } = {}) {
    // Usage: svlib.colorResponse.call(this, questionId, responseText);
    // TODO: take choiceId instead of responseText.
        console.groupCollapsed("colorResponse(%s, %s)", questionId, responseText);
        qInstance = Qualtrics.SurveyEngine.QuestionData.getInstance(questionId);
        const questionContainer = qInstance.getQuestionContainer();
        if (!questionContainer) { /* ... safety check ... */ return; }
        // We want to apply the background color to the div class="choice-error".
        const choiceElements = questionContainer.querySelectorAll(".choice-label .rich-text");
        const choiceElement = Array.from(choiceElements).find((el) => {
            const text = el.textContent.trim();
            return text === responseText;
        });
        if (choiceElement) {
            const label = choiceElement.closest(".choice-label");
            if (!label) {
                svlib.warn("colorResponse: Could not find label for choice element:", choiceElement);
                return;
            }
            // Apply the color to the label
            label.style.backgroundColor = color;
        } else {
            svlib.warn("colorResponse: Could not find label in choice element:", questionContainer);
        }

        if (record) {
            const historyKey = `${questionId}_colorHistory`;
            // Load existing map or start fresh
            const colorMap = svlib.loadSessionJson(questionId + "_colorHistory") ?? {};
            colorMap[responseText] = color;
            svlib.saveSessionJson(questionId + "_colorHistory", colorMap);
            svlib.log("  → recorded colorHistory:", colorMap);
        }
            console.groupEnd();
    };


    


    svlib.checkAttemptsCQ = function checkAttemptsCQ(questionId, correctIndex = 0) {
    // Usage: let attemptsTaken = svlib.checkAttemptsCQ.call(this, this.questionId);
        console.groupCollapsed("checkAttemptsCQ(%s, correctIndex=%s)", questionId, correctIndex);
        // const questionId = this.questionId;
        const responseHistory = svlib.loadSessionJson(questionId + "_responseHistory") || [];
        const naturalChoiceOrder = svlib.loadSessionJson(questionId + "_naturalChoiceOrder");
        const correctIndexText = naturalChoiceOrder[correctIndex];
        let attemptsTaken = null;

        if (responseHistory.length === 0) {
            svlib.log("No responses recorded yet.");
        }
        else if (responseHistory.length > 0) {
            // From 0 to check_up_to, check if the response is correct. Record the first correct response.
            for (let i = 0; i < responseHistory.length; i++) {
                const responseText = responseHistory[i];
                if (responseText === correctIndexText) {
                    attemptsTaken = i + 1;
                    svlib.log("Correct response found in %s attempts: %s", attemptsTaken, responseText);
                    break;
                }
            }
        }
        // Append attemptsTaken to the CQ Attempts data
        let attemptsData = svlib.loadSessionJson("attemptsTakenCQ") ?? {};
        attemptsData[questionId] = attemptsTaken;
        svlib.saveSessionJson("attemptsTakenCQ", attemptsData);
        console.groupEnd();
        return attemptsTaken;
    };

    svlib.checkAttemptsCQOnUnload = function checkAttemptsCQOnUnload() {
        // Usage: svlib.checkAttemptsCQOnUnload.call(this); this can be called in .addOnload() or .addOnReady().
        console.groupCollapsed("checkAttemptsCQOnUnload()");
        const questionId = this.questionId;
        const that = this;

        Qualtrics.SurveyEngine.addOnUnload(function () {
            const attempts = svlib.checkAttemptsCQ.call(that, questionId);
        });
        console.groupEnd();
    };

    svlib.scoreAttemptsCQ = function scoreAttemptsCQ(attemptsTaken, payoff_ladder) {
    // Usage: svlib.scoreAttemptsCQ.call(this, payoff_ladder);
    // We'll probably set payoff_ladder as an embedded variable; remember to assign it before calling this function.
    // TODO: We can checkAttempts on Submit, but don't score until the end of the survey. Maybe keep a list of attemptsTaken, then sum them at the end. We don't want resubmitting to keep incrementing the score.
        console.groupCollapsed("scoreAttemptsCQ(payoff_ladder=%s)", payoff_ladder);
        const questionId = this.questionId;



        console.groupEnd();
    };


    svlib.hideChoices = function hideChoices(choiceIndexes) {
    // Usage: svlib.hideChoices.call(this, choiceIndexes);
    // Note: Hiding before randomization will not affect the randomization process. Example: hideChoices(this, [3]) ensures that the natural choice 3 is hidden, and the other choices are shown in a randomized order.
        const questionContainer = this.getQuestionContainer();
        const allChoices = questionContainer.querySelectorAll(".choice.radio");
        choiceIndexes.forEach((index) => {
            const target = allChoices[index - 1]; // Adjust for 0-based index
            if (target) {
                target.style.display = "none";
            }
        });
    };


    svlib.hideChoicesUnlessDebug = function hideChoicesUnlessDebug(choiceIndexes) {
    // Usage: svlib.hideChoicesUnlessDebug.call(this, choiceIndexes);
        if (svlib.DEBUG_MODE == false) {
            svlib.hideChoices.call(this, choiceIndexes);
        };
    };

    svlib.markChoicesAsCursed = function markChoicesAsCursed(choiceIndexes) {
    // Usage: svlib.markChoicesAsCursed.call(this, choiceIndexes);
    // For each index in choiceIndexes, add an event listener to the choice. If clicked, start the TextCorruptor and remove the listener.
    // If the choice is selected on page submit, then set sessionStorage("cursed") to true.

        const questionContainer = this.getQuestionContainer();
        const allChoices = questionContainer.querySelectorAll(".choice.radio");
        choiceIndexes.forEach((index) => {
            const target = allChoices[index - 1]; // Adjust for 0-based index
            if (target) {
                target.classList.add("cursed");
                target.addEventListener("click", function () {
                    svlib.log("Cursed choice clicked. Starting TextCorruptor.");
                    const corruptor = new svlib.TextCorruptor(questionContainer, { baseInterval: 5000, minInterval: 100, growthFactor: 1.1, baseCount: 1 });
                    corruptor.start();
                    target.removeEventListener("click", arguments.callee);
                });
            }
        });

        Qualtrics.SurveyEngine.addOnPageSubmit(function () {
            const selectedChoice = questionContainer.querySelector(".choice.radio input:checked");
            // const selectedChoice = this.getSelectedChoices();
            // TODO: Probably compare to natural choice order. Also, decouple the randomization from the other functions.
            svlib.log("Selected choice on submit: %o", selectedChoice);
            if (selectedChoice) {
                const selectedIndex = Array.from(allChoices).indexOf(selectedChoice[0]);
                if (choiceIndexes.includes(selectedIndex + 1)) {
                    svlib.log("Selected choice index: %s. Marking as cursed...", selectedIndex);
                    sessionStorage.setItem("cursed", "true");
                }
            }
        });
    };


    svlib.checkIfCursed = function checkIfCursed() {
    // Usage: svlib.checkIfCursed.call(this);
    // If the session variable "cursed" is "true", then the TextCorruptor is started.
        const questionContainer = this.getQuestionContainer();
        const cursed = sessionStorage.getItem("cursed");
        svlib.log("Checking if cursed: %s", cursed);
        if (cursed === "true") {
            svlib.log("Cursed embedded variable is true. Starting TextCorruptor.");
            const corruptor = new svlib.TextCorruptor(questionContainer, { baseInterval: 5000, minInterval: 100, growthFactor: 1.1, baseCount: 1 });
            corruptor.start();
        }
    };


    svlib.collectTextNodes = function collectTextNodes(root) {
        // Usage: 
        const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, null, false);
        const nodes = [];
        while ((node = walker.nextNode())) {
            if (node.nodeType === Node.TEXT_NODE && node.nodeValue.trim() !== "") {
                nodes.push(node);
            }
        }
        return nodes;

    };


    svlib.injectDiacritic = function injectDiacritic(str, diacritics) {
        if (!str) return str;
        const chars = Array.from(str);
        const pos = Math.floor(Math.random() * chars.length);
        const mark = diacritics[Math.floor(Math.random() * diacritics.length)];
        chars[pos] = chars[pos] + mark;
        return chars.join("");
    };


    svlib.TextCorruptor = class TextCorruptor {
        // Usage:
        // const corruptor = new svlib.TextCorruptor(this.getQuestionContainer(), { baseInterval: 5000, minInterval: 100, growthFactor: 1.1, baseCount: 1 });
        // corruptor.start();

        constructor(containerOrSelector, opts) {
            if (typeof containerOrSelector === "string") {
                this.container = document.querySelector(containerOrSelector);
            } else if (containerOrSelector instanceof Element) {
                this.container = containerOrSelector;
            }

            if (!this.container) {
                svlib.error("TextCorruptor: Container not found.");
                return;
            }

            Object.assign(this, {
                baseInterval: opts.baseInterval || 5000,
                minInterval: opts.minInterval || 100,
                growthFactor: opts.growthFactor || 1.1,
                baseCount: opts.baseCount || 1,
                diacritics:  [
                '\u0300', '\u0301', '\u0302', '\u0303', '\u0304', '\u0305', '\u0306',
                '\u0307', '\u0308', '\u0309', '\u030A', '\u030B', '\u030C', '\u030D',
                '\u030E', '\u030F', '\u0310', '\u0311', '\u0312', '\u0313', '\u0314',
                '\u0315', '\u0316', '\u0317', '\u0318', '\u0319', '\u031A'
                ]
            });

            this._startTime = Date.now();
            this._timer = null;
            this._tick = 0;
        };

        start() {
            svlib.log("TextCorruptor started: %s every %s ms", this.baseCount, this.baseInterval);
            this._schedule();
        }

        stop() {
            clearTimeout(this._timer);
            svlib.log("TextCorruptor stopped.");
        }

        _schedule() {
            this._timer = setTimeout(() => this._runTick(), this.interval);
        }

        _runTick() {
            this._tick += 1;

            const elapsedTime = (Date.now() - this._startTime) / 1000;
            const newInterval = Math.max(this.minInterval, this.baseInterval / Math.pow(this.growthFactor, elapsedTime));
            this.interval = newInterval;
            this.count = 1 + Math.floor(elapsedTime / 2);

            const nodes = svlib.collectTextNodes(this.container);
            if (!nodes.length) {
                svlib.warn("TextCorruptor: No text nodes found in container.");
                return;
            }
            for (let i = 0; i < this.count; i++) {
                const n = nodes[Math.floor(Math.random() * nodes.length)];
                const before = n.textContent;
                const after = svlib.injectDiacritic(before, this.diacritics);
                n.textContent = after;
            }

            this._schedule();
        }
    };







  // --- Define variables/constants as properties ---
  svlib.SURVEY_VERSION = "0.2.3";

  console.log("Custom header script loaded. svlib namespace configured. v" + svlib.SURVEY_VERSION);
</script>
<!-- End Qualtrics Survey Header -->
